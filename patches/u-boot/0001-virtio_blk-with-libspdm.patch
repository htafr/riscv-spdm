From d901c3f500b82a1b77d22f4ce0d74e1c53e8197d Mon Sep 17 00:00:00 2001
From: offreitas <offreitas@outlook.com>
Date: Wed, 8 Nov 2023 14:35:14 -0300
Subject: [PATCH 1/2] virtio_blk with libspdm

---
 Kconfig                         |   5 +
 drivers/virtio/Makefile         |   3 +
 drivers/virtio/spdm_flags.c     | 207 ++++++++++
 drivers/virtio/spdm_virtioblk.h |  73 ++++
 drivers/virtio/virtio_blk.c     | 670 +++++++++++++++++++++++++++++++-
 drivers/virtio/virtio_blk.h     |   4 +
 include/blk.h                   |   4 +
 lib/Makefile                    |   2 +
 lib/sha256.c                    |   3 +-
 lib/spdm/Makefile               |  54 +++
 lib/spdm/spdm_glue.c            | 205 ++++++++++
 11 files changed, 1222 insertions(+), 8 deletions(-)
 create mode 100644 drivers/virtio/spdm_flags.c
 create mode 100644 drivers/virtio/spdm_virtioblk.h
 create mode 100644 lib/spdm/Makefile
 create mode 100644 lib/spdm/spdm_glue.c

diff --git a/Kconfig b/Kconfig
index 70efb41cc6..0e7c4e9e64 100644
--- a/Kconfig
+++ b/Kconfig
@@ -585,6 +585,11 @@ config MP
 	  This provides an option to bringup different processors
 	  in multiprocessor cases.
 
+config SPDM
+	bool "Enable SPDM"
+	help
+		This enables SPDM to verify virtio block devices.
+
 endmenu		# General setup
 
 source "api/Kconfig"
diff --git a/drivers/virtio/Makefile b/drivers/virtio/Makefile
index 4c63a6c690..db18e5b1ed 100644
--- a/drivers/virtio/Makefile
+++ b/drivers/virtio/Makefile
@@ -11,3 +11,6 @@ obj-$(CONFIG_VIRTIO_SANDBOX) += virtio_sandbox.o
 obj-$(CONFIG_VIRTIO_NET) += virtio_net.o
 obj-$(CONFIG_VIRTIO_BLK) += virtio_blk.o
 obj-$(CONFIG_VIRTIO_RNG) += virtio_rng.o
+
+SPDM_INCLUDE := -Iinclude/spdm -Iinclude/spdm/hal
+CFLAGS_virtio_blk.o = $(SPDM_INCLUDE)
diff --git a/drivers/virtio/spdm_flags.c b/drivers/virtio/spdm_flags.c
new file mode 100644
index 0000000000..9f6e6fe6a6
--- /dev/null
+++ b/drivers/virtio/spdm_flags.c
@@ -0,0 +1,207 @@
+/**
+    Copyright Notice:
+    Copyright 2021 DMTF. All rights reserved.
+    License: BSD 3-Clause License. For full text see link: https://github.com/DMTF/spdm-emu/blob/main/LICENSE.md
+**/
+
+// #include "spdm_emu.h"
+#include <library/spdm_transport_mctp_lib.h>
+
+#define SPDM_BLK_APP_TAMPER   0x01
+#define SPDM_BLK_APP_MSG      0x02
+
+#define SOCKET_TRANSPORT_TYPE_MCTP 0x01
+#define SOCKET_TRANSPORT_TYPE_PCI_DOE 0x02
+
+static uint32 m_use_transport_layer = SOCKET_TRANSPORT_TYPE_MCTP;
+
+static uint8 m_use_version = SPDM_MESSAGE_VERSION_11;
+static uint8 m_use_secured_message_version = SPDM_MESSAGE_VERSION_11;
+static uint32 m_use_requester_capability_flags =
+	(0 |
+	 SPDM_GET_CAPABILITIES_REQUEST_FLAGS_CERT_CAP | /* conflict with SPDM_GET_CAPABILITIES_REQUEST_FLAGS_PUB_KEY_ID_CAP */
+	 SPDM_GET_CAPABILITIES_REQUEST_FLAGS_CHAL_CAP |
+	 SPDM_GET_CAPABILITIES_REQUEST_FLAGS_ENCRYPT_CAP |
+	 SPDM_GET_CAPABILITIES_REQUEST_FLAGS_MAC_CAP |
+	 SPDM_GET_CAPABILITIES_REQUEST_FLAGS_MUT_AUTH_CAP |
+	 SPDM_GET_CAPABILITIES_REQUEST_FLAGS_KEY_EX_CAP |
+	 SPDM_GET_CAPABILITIES_REQUEST_FLAGS_PSK_CAP_REQUESTER |
+	 SPDM_GET_CAPABILITIES_REQUEST_FLAGS_ENCAP_CAP |
+	 SPDM_GET_CAPABILITIES_REQUEST_FLAGS_HBEAT_CAP |
+	 SPDM_GET_CAPABILITIES_REQUEST_FLAGS_KEY_UPD_CAP |
+	 SPDM_GET_CAPABILITIES_REQUEST_FLAGS_HANDSHAKE_IN_THE_CLEAR_CAP |
+	 // SPDM_GET_CAPABILITIES_REQUEST_FLAGS_PUB_KEY_ID_CAP | /* conflict with SPDM_GET_CAPABILITIES_REQUEST_FLAGS_CERT_CAP */
+	 0);
+// static uint32 m_use_responder_capability_flags =
+// 	(0 | SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_CACHE_CAP |
+// 	 SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_CERT_CAP | /* conflict with SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_PUB_KEY_ID_CAP */
+// 	 SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_CHAL_CAP |
+// 	 // SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_MEAS_CAP_NO_SIG | /* conflict with SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_MEAS_CAP_SIG */
+// 	 SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_MEAS_CAP_SIG | /* conflict with SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_MEAS_CAP_NO_SIG */
+// 	 SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_MEAS_FRESH_CAP |
+// 	 SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_ENCRYPT_CAP |
+// 	 SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_MAC_CAP |
+// 	 SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_MUT_AUTH_CAP |
+// 	 SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_KEY_EX_CAP |
+// 	 // SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_PSK_CAP_RESPONDER | /* conflict with SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_PSK_CAP_RESPONDER_WITH_CONTEXT */
+// 	 SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_PSK_CAP_RESPONDER_WITH_CONTEXT | /* conflict with SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_PSK_CAP_RESPONDER */
+// 	 SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_ENCAP_CAP |
+// 	 SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_HBEAT_CAP |
+// 	 SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_KEY_UPD_CAP |
+// 	 SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_HANDSHAKE_IN_THE_CLEAR_CAP |
+// 	 // SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_PUB_KEY_ID_CAP | /* conflict with SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_CERT_CAP */
+// 	 0);
+
+static uint32 m_use_capability_flags = 0;
+/*
+  0
+  1
+*/
+// static uint8 m_use_basic_mut_auth = 1;
+/*
+  0
+  SPDM_KEY_EXCHANGE_RESPONSE_MUT_AUTH_REQUESTED,
+  SPDM_KEY_EXCHANGE_RESPONSE_MUT_AUTH_REQUESTED_WITH_ENCAP_REQUEST,
+  SPDM_KEY_EXCHANGE_RESPONSE_MUT_AUTH_REQUESTED_WITH_GET_DIGESTS
+*/
+// static uint8 m_use_mut_auth =
+// 	SPDM_KEY_EXCHANGE_RESPONSE_MUT_AUTH_REQUESTED_WITH_ENCAP_REQUEST;
+/*
+  SPDM_CHALLENGE_REQUEST_NO_MEASUREMENT_SUMMARY_HASH,
+  SPDM_CHALLENGE_REQUEST_TCB_COMPONENT_MEASUREMENT_HASH,
+  SPDM_CHALLENGE_REQUEST_ALL_MEASUREMENTS_HASH
+*/
+static uint8 m_use_measurement_summary_hash_type =
+	SPDM_CHALLENGE_REQUEST_ALL_MEASUREMENTS_HASH;
+/*
+  SPDM_GET_MEASUREMENTS_REQUEST_MEASUREMENT_OPERATION_TOTAL_NUMBER_OF_MEASUREMENTS, // one by one
+  SPDM_GET_MEASUREMENTS_REQUEST_MEASUREMENT_OPERATION_ALL_MEASUREMENTS
+*/
+// static uint8 m_use_measurement_operation =
+// 	SPDM_GET_MEASUREMENTS_REQUEST_MEASUREMENT_OPERATION_TOTAL_NUMBER_OF_MEASUREMENTS;
+static uint8 m_use_slot_id = 0;
+static uint8 m_use_slot_count = 3;
+
+/*
+  SPDM_KEY_UPDATE_ACTION_REQUESTER
+  SPDM_KEY_UPDATE_ACTION_RESPONDER
+  SPDM_KEY_UPDATE_ACTION_ALL
+*/
+spdm_key_update_action_t m_use_key_update_action = SPDM_KEY_UPDATE_ACTION_ALL;
+
+static uint32 m_use_hash_algo;
+static uint32 m_use_measurement_hash_algo;
+static uint32 m_use_asym_algo;
+static uint16 m_use_req_asym_algo;
+
+/*
+  SPDM_MEASUREMENT_BLOCK_HEADER_SPECIFICATION_DMTF,
+*/
+static uint8 m_support_measurement_spec =
+	SPDM_MEASUREMENT_BLOCK_HEADER_SPECIFICATION_DMTF;
+/*
+  SPDM_ALGORITHMS_MEASUREMENT_HASH_ALGO_TPM_ALG_SHA3_512,
+  SPDM_ALGORITHMS_MEASUREMENT_HASH_ALGO_TPM_ALG_SHA3_384,
+  SPDM_ALGORITHMS_MEASUREMENT_HASH_ALGO_TPM_ALG_SHA3_256,
+  SPDM_ALGORITHMS_MEASUREMENT_HASH_ALGO_TPM_ALG_SHA_512,
+  SPDM_ALGORITHMS_MEASUREMENT_HASH_ALGO_TPM_ALG_SHA_384,
+  SPDM_ALGORITHMS_MEASUREMENT_HASH_ALGO_TPM_ALG_SHA_256,
+  SPDM_ALGORITHMS_MEASUREMENT_HASH_ALGO_RAW_BIT_STREAM_ONLY,
+*/
+// static uint32 m_support_measurement_hash_algo =
+// 	SPDM_ALGORITHMS_MEASUREMENT_HASH_ALGO_TPM_ALG_SHA_512 |
+// 	SPDM_ALGORITHMS_MEASUREMENT_HASH_ALGO_TPM_ALG_SHA_384;
+/*
+  SPDM_ALGORITHMS_BASE_HASH_ALGO_TPM_ALG_SHA_512,
+  SPDM_ALGORITHMS_BASE_HASH_ALGO_TPM_ALG_SHA_384,
+  SPDM_ALGORITHMS_BASE_HASH_ALGO_TPM_ALG_SHA_256,
+*/
+static uint32 m_support_hash_algo =
+            SPDM_ALGORITHMS_BASE_HASH_ALGO_TPM_ALG_SHA_384 |
+			      SPDM_ALGORITHMS_BASE_HASH_ALGO_TPM_ALG_SHA_256;
+/*
+  SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_ECDSA_ECC_NIST_P521,
+  SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_ECDSA_ECC_NIST_P384,
+  SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_ECDSA_ECC_NIST_P256,
+  SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSAPSS_4096,
+  SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSASSA_4096,
+  SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSAPSS_3072,
+  SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSASSA_3072,
+  SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSAPSS_2048,
+  SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSASSA_2048,
+*/
+static uint32 m_support_asym_algo =
+	SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_ECDSA_ECC_NIST_P384 |
+	SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_ECDSA_ECC_NIST_P256;
+/*
+  SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSAPSS_4096,
+  SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSASSA_4096,
+  SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSAPSS_3072,
+  SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSASSA_3072,
+  SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSAPSS_2048,
+  SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSASSA_2048,
+  SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_ECDSA_ECC_NIST_P521,
+  SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_ECDSA_ECC_NIST_P384,
+  SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_ECDSA_ECC_NIST_P256,
+*/
+static uint16 m_support_req_asym_algo =
+	SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSAPSS_3072 |
+	SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSAPSS_2048 |
+	SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSASSA_3072 |
+	SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSASSA_2048;
+/*
+  SPDM_ALGORITHMS_DHE_NAMED_GROUP_FFDHE_4096,
+  SPDM_ALGORITHMS_DHE_NAMED_GROUP_FFDHE_3072,
+  SPDM_ALGORITHMS_DHE_NAMED_GROUP_FFDHE_2048,
+  SPDM_ALGORITHMS_DHE_NAMED_GROUP_SECP_521_R1,
+  SPDM_ALGORITHMS_DHE_NAMED_GROUP_SECP_384_R1,
+  SPDM_ALGORITHMS_DHE_NAMED_GROUP_SECP_256_R1,
+*/
+static uint16 m_support_dhe_algo = SPDM_ALGORITHMS_DHE_NAMED_GROUP_SECP_384_R1 |
+			    SPDM_ALGORITHMS_DHE_NAMED_GROUP_SECP_256_R1 |
+			    SPDM_ALGORITHMS_DHE_NAMED_GROUP_FFDHE_3072 |
+			    SPDM_ALGORITHMS_DHE_NAMED_GROUP_FFDHE_2048;
+/*
+  SPDM_ALGORITHMS_AEAD_CIPHER_SUITE_AES_256_GCM,
+  SPDM_ALGORITHMS_AEAD_CIPHER_SUITE_AES_128_GCM,
+  SPDM_ALGORITHMS_AEAD_CIPHER_SUITE_CHACHA20_POLY1305,
+*/
+static uint16 m_support_aead_algo =
+	SPDM_ALGORITHMS_AEAD_CIPHER_SUITE_AES_256_GCM |
+	SPDM_ALGORITHMS_AEAD_CIPHER_SUITE_CHACHA20_POLY1305;
+/*
+  SPDM_ALGORITHMS_KEY_SCHEDULE_HMAC_HASH,
+*/
+static uint16 m_support_key_schedule_algo = SPDM_ALGORITHMS_KEY_SCHEDULE_HMAC_HASH;
+
+
+#define EXE_MODE_SHUTDOWN 0
+#define EXE_MODE_CONTINUE 1
+// extern uint32 m_exe_mode;
+
+#define EXE_CONNECTION_VERSION_ONLY 0x1
+#define EXE_CONNECTION_DIGEST 0x2
+#define EXE_CONNECTION_CERT 0x4
+#define EXE_CONNECTION_CHAL 0x8
+#define EXE_CONNECTION_MEAS 0x10
+// extern uint32 m_exe_connection;
+
+#define EXE_SESSION_KEY_EX 0x1
+#define EXE_SESSION_PSK 0x2
+#define EXE_SESSION_NO_END 0x4
+#define EXE_SESSION_KEY_UPDATE 0x8
+#define EXE_SESSION_HEARTBEAT 0x10
+#define EXE_SESSION_MEAS 0x20
+// extern uint32 m_exe_session;
+
+// static uint32 m_exe_mode = EXE_MODE_SHUTDOWN;
+
+static uint32 m_exe_connection = (0 |
+         // EXE_CONNECTION_VERSION_ONLY |
+         EXE_CONNECTION_DIGEST | EXE_CONNECTION_CERT |
+         EXE_CONNECTION_CHAL | EXE_CONNECTION_MEAS | 0);
+
+// static uint32 m_exe_session =
+//   (0 | EXE_SESSION_KEY_EX | EXE_SESSION_PSK |
+//    // EXE_SESSION_NO_END |
+//    EXE_SESSION_KEY_UPDATE | EXE_SESSION_HEARTBEAT | EXE_SESSION_MEAS | 0);
\ No newline at end of file
diff --git a/drivers/virtio/spdm_virtioblk.h b/drivers/virtio/spdm_virtioblk.h
new file mode 100644
index 0000000000..a97476d780
--- /dev/null
+++ b/drivers/virtio/spdm_virtioblk.h
@@ -0,0 +1,73 @@
+#ifndef _SPDM_VBLK_H_
+#define _SPDM_VBLK_H_
+
+#include <spdm_common_lib.h>
+#include <library/spdm_requester_lib.h>
+#include <library/spdm_transport_mctp_lib.h>
+#include <industry_standard/mctp.h>
+#include <spdm_requester_lib_internal.h>
+#include <spdm_secured_message_lib_internal.h>
+#include "spdm_flags.c"
+
+#define BLK_SPDM_DEBUG 1
+#define TEST_PSK_DATA_STRING "TestPskData"
+#define TEST_PSK_HINT_STRING "TestPskHint"
+#define SPDM_CTX_TO_VIRTIOBLK(spdm_context_ptr) *(struct blk_desc**)((char*)(spdm_context_ptr) + spdm_get_context_size())
+
+return_status spdm_virtblk_send_message(
+	IN void* spdm_context,
+	IN uintn request_size,
+	IN void* request,
+	IN uint64 timeout
+);
+
+return_status spdm_virtblk_receive_message(
+	IN 			void*		spdm_context,
+	IN OUT 	uintn*	response_size,
+	IN OUT 	void*		response,
+	IN 			uint64	timeout
+);
+
+void* virtblk_init_spdm(void);
+void virtblk_init_spdm_certificates(void* spdm_context);
+
+/**
+ * This function executes SPDM authentication.
+ * 
+ * @param[in]  spdm_context            The SPDM context for the device.
+ */
+return_status do_authentication_via_spdm(void* spdm_context);
+
+/**
+ * This function sends GET_DIGEST, GET_CERTIFICATE, CHALLENGE
+ * to authenticate the device.
+ * 
+ * This function is combination of spdm_get_digest, spdm_get_certificate, spdm_challenge.
+ * 
+ * @param  spdm_context                  A pointer to the SPDM context.
+ * @param  slot_mask                     The slots which deploy the CertificateChain.
+ * @param  total_digest_buffer            A pointer to a destination buffer to store the digest buffer.
+ * @param  slot_id                      The number of slot for the certificate chain.
+ * @param  cert_chain_size                On input, indicate the size in bytes of the destination buffer to store the digest buffer.
+ *                                        On output, indicate the size in bytes of the certificate chain.
+ * @param  cert_chain                    A pointer to a destination buffer to store the certificate chain.
+ * @param  measurement_hash_type          The type of the measurement hash.
+ * @param  measurement_hash              A pointer to a destination buffer to store the measurement hash.
+ * 
+ * @retval RETURN_SUCCESS               The authentication is got successfully.
+ * @retval RETURN_DEVICE_ERROR          A device error occurs when communicates with the device.
+ * @retval RETURN_SECURITY_VIOLATION    Any verification fails.
+ * */
+return_status
+spdm_authentication(
+	IN 			void 		*context,
+	OUT 		uint8 	*slot_mask,
+	OUT 		void 		*total_digest_buffer,
+	IN 			uint8 	slot_id,
+	IN OUT 	uintn 	*cert_chain_size,
+	OUT 		void 		*cert_chain,
+	IN 			uint8 	measurement_hash_type,
+	OUT 		void 		*measurement_hash
+	);
+
+#endif /* _SPDM_VBLK_H_ */
diff --git a/drivers/virtio/virtio_blk.c b/drivers/virtio/virtio_blk.c
index 9581058286..f6795ae3e7 100644
--- a/drivers/virtio/virtio_blk.c
+++ b/drivers/virtio/virtio_blk.c
@@ -8,17 +8,38 @@
 
 #include <common.h>
 #include <blk.h>
+#include <malloc.h>
 #include <dm.h>
 #include <part.h>
 #include <virtio_types.h>
 #include <virtio.h>
 #include <virtio_ring.h>
+#include <string.h>
+#include <stdio.h>
 #include "virtio_blk.h"
 
+#if CONFIG_IS_ENABLED(SPDM)
+#define BLK_SPDM_DEBUG 1
+#include "spdm_virtioblk.h"
+
+// read_responder_public_certificate_chain
+static uintn responder_public_certificate_chain_size = 519;
+static uint8 responder_public_certificate_chain_data[] = { 0x07, 0x02, 0x00, 0x00, 0x5A, 0x64, 0xB3, 0x8B, 0x5D, 0x5F, 0x4D, 0xB3, 0x5F, 0xB2, 0xAA, 0x1D, 0x46, 0x9F, 0x6A, 0xDC, 0xCA, 0x7F, 0xAC, 0x85, 0xBE, 0xF0, 0x84, 0x10, 0x9C, 0xCD, 0x54, 0x09, 0xF0, 0xAB, 0x38, 0x3A, 0xAA, 0xF7, 0xA6, 0x2E, 0x3B, 0xD7, 0x81, 0x2C, 0xEA, 0x24, 0x7E, 0x14, 0xA9, 0x56, 0x9D, 0x28, 0x30, 0x82, 0x01, 0xCF, 0x30, 0x82, 0x01, 0x56, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x14, 0x20, 0x3A, 0xC2, 0x59, 0xCC, 0xDA, 0xCB, 0xF6, 0x72, 0xF1, 0xC0, 0x1A, 0x62, 0x1A, 0x45, 0x82, 0x90, 0x24, 0xB8, 0xAF, 0x30, 0x0A, 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x04, 0x03, 0x03, 0x30, 0x1F, 0x31, 0x1D, 0x30, 0x1B, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0C, 0x14, 0x69, 0x6E, 0x74, 0x65, 0x6C, 0x20, 0x74, 0x65, 0x73, 0x74, 0x20, 0x45, 0x43, 0x50, 0x32, 0x35, 0x36, 0x20, 0x43, 0x41, 0x30, 0x1E, 0x17, 0x0D, 0x32, 0x31, 0x30, 0x32, 0x30, 0x39, 0x30, 0x30, 0x35, 0x30, 0x35, 0x38, 0x5A, 0x17, 0x0D, 0x33, 0x31, 0x30, 0x32, 0x30, 0x37, 0x30, 0x30, 0x35, 0x30, 0x35, 0x38, 0x5A, 0x30, 0x1F, 0x31, 0x1D, 0x30, 0x1B, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0C, 0x14, 0x69, 0x6E, 0x74, 0x65, 0x6C, 0x20, 0x74, 0x65, 0x73, 0x74, 0x20, 0x45, 0x43, 0x50, 0x32, 0x35, 0x36, 0x20, 0x43, 0x41, 0x30, 0x76, 0x30, 0x10, 0x06, 0x07, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x02, 0x01, 0x06, 0x05, 0x2B, 0x81, 0x04, 0x00, 0x22, 0x03, 0x62, 0x00, 0x04, 0x99, 0x8F, 0x81, 0x68, 0x9A, 0x83, 0x9B, 0x83, 0x39, 0xAD, 0x0E, 0x32, 0x8D, 0xB9, 0x42, 0x0D, 0xAE, 0xCC, 0x91, 0xA9, 0xBC, 0x4A, 0xE1, 0xBB, 0x79, 0x4C, 0x22, 0xFA, 0x3F, 0x0C, 0x9D, 0x93, 0x3C, 0x1A, 0x02, 0x5C, 0xC2, 0x73, 0x05, 0xEC, 0x43, 0x5D, 0x04, 0x02, 0xB1, 0x68, 0xB3, 0xF4, 0xD8, 0xDE, 0x0C, 0x8D, 0x53, 0xB7, 0x04, 0x8E, 0xA1, 0x43, 0x9A, 0xEB, 0x31, 0x0D, 0xAA, 0xCE, 0x89, 0x2D, 0xBA, 0x73, 0xDA, 0x4F, 0x1E, 0x39, 0x5D, 0x92, 0x11, 0x21, 0x38, 0xB4, 0x00, 0xD4, 0xF5, 0x55, 0x8C, 0xE8, 0x71, 0x30, 0x3D, 0x46, 0x83, 0xF4, 0xC4, 0x52, 0x50, 0xDA, 0x12, 0x5B, 0xA3, 0x53, 0x30, 0x51, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x1D, 0x0E, 0x04, 0x16, 0x04, 0x14, 0xCF, 0x09, 0xD4, 0x7A, 0xEE, 0x08, 0x90, 0x62, 0xBF, 0xE6, 0x9C, 0xB4, 0xB9, 0xDF, 0xE1, 0x41, 0x33, 0x1C, 0x03, 0xA5, 0x30, 0x1F, 0x06, 0x03, 0x55, 0x1D, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14, 0xCF, 0x09, 0xD4, 0x7A, 0xEE, 0x08, 0x90, 0x62, 0xBF, 0xE6, 0x9C, 0xB4, 0xB9, 0xDF, 0xE1, 0x41, 0x33, 0x1C, 0x03, 0xA5, 0x30, 0x0F, 0x06, 0x03, 0x55, 0x1D, 0x13, 0x01, 0x01, 0xFF, 0x04, 0x05, 0x30, 0x03, 0x01, 0x01, 0xFF, 0x30, 0x0A, 0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x04, 0x03, 0x03, 0x03, 0x67, 0x00, 0x30, 0x64, 0x02, 0x30, 0x5A, 0xB4, 0xF5, 0x95, 0x25, 0x82, 0xF6, 0x68, 0x3E, 0x49, 0xC7, 0xB4, 0xBB, 0x42, 0x81, 0x91, 0x7E, 0x38, 0xD0, 0x2D, 0xAC, 0x53, 0xAE, 0x8E, 0xB0, 0x51, 0x50, 0xAA, 0xF8, 0x7E, 0xFF, 0xC0, 0x30, 0xAB, 0xD5, 0x08, 0x5B, 0x06, 0xF7, 0xE1, 0xBF, 0x39, 0xD2, 0x3E, 0xAE, 0xBF, 0x8E, 0x48, 0x02, 0x30, 0x09, 0x75, 0xA8, 0xC0, 0x6F, 0x4F, 0x3C, 0xAD, 0x5D, 0x4E, 0x4F, 0xF8, 0x2C, 0x3B, 0x39, 0x46, 0xA0, 0xDF, 0x83, 0x8E, 0xB5, 0xD3, 0x61, 0x61, 0x59, 0xBC, 0x39, 0xD7, 0xAD, 0x68, 0x5E, 0x0D, 0x4F, 0x3F, 0xE2, 0xCA, 0xC1, 0x74, 0x8F, 0x47, 0x37, 0x11, 0xC8, 0x22, 0x59, 0x6F, 0x64, 0x52 };
+static uintn responder_public_certificate_chain_hash_size = 48;
+static uint8 responder_public_certificate_chain_hash[] = { 0x5A, 0x64, 0xB3, 0x8B, 0x5D, 0x5F, 0x4D, 0xB3, 0x5F, 0xB2, 0xAA, 0x1D, 0x46, 0x9F, 0x6A, 0xDC, 0xCA, 0x7F, 0xAC, 0x85, 0xBE, 0xF0, 0x84, 0x10, 0x9C, 0xCD, 0x54, 0x09, 0xF0, 0xAB, 0x38, 0x3A, 0xAA, 0xF7, 0xA6, 0x2E, 0x3B, 0xD7, 0x81, 0x2C, 0xEA, 0x24, 0x7E, 0x14, 0xA9, 0x56, 0x9D, 0x28 };
+// read_requester_public_certificate_chain
+static uintn requester_public_certificate_chain_size = 3684;
+static uint8 requester_public_certificate_chain_data[] = { 0x64, 0x0E, 0x00, 0x00, 0xFA, 0x96, 0xED, 0xD0, 0x70, 0xD1, 0xD3, 0xC9, 0xC9, 0xC5, 0xF6, 0xD9, 0x49, 0x06, 0x8D, 0x2F, 0xC1, 0xB1, 0x99, 0xF8, 0xBE, 0xA6, 0x13, 0x36, 0x03, 0x04, 0x01, 0x54, 0x35, 0x3A, 0x79, 0xB5, 0x8F, 0xB0, 0x8E, 0x93, 0x8E, 0xCB, 0x1A, 0x1D, 0x8C, 0xEA, 0x42, 0x97, 0x0D, 0xC4, 0x3C, 0x35, 0x30, 0x82, 0x05, 0x19, 0x30, 0x82, 0x03, 0x01, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x14, 0x13, 0x11, 0x90, 0x02, 0xDF, 0x80, 0xE6, 0x81, 0x20, 0x66, 0x79, 0x36, 0xF9, 0x60, 0x53, 0xAD, 0x34, 0xAC, 0x29, 0xBF, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x0B, 0x05, 0x00, 0x30, 0x1C, 0x31, 0x1A, 0x30, 0x18, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0C, 0x11, 0x69, 0x6E, 0x74, 0x65, 0x6C, 0x20, 0x74, 0x65, 0x73, 0x74, 0x20, 0x52, 0x53, 0x41, 0x20, 0x43, 0x41, 0x30, 0x1E, 0x17, 0x0D, 0x32, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x37, 0x34, 0x35, 0x33, 0x36, 0x5A, 0x17, 0x0D, 0x33, 0x30, 0x31, 0x30, 0x30, 0x38, 0x30, 0x37, 0x34, 0x35, 0x33, 0x36, 0x5A, 0x30, 0x1C, 0x31, 0x1A, 0x30, 0x18, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0C, 0x11, 0x69, 0x6E, 0x74, 0x65, 0x6C, 0x20, 0x74, 0x65, 0x73, 0x74, 0x20, 0x52, 0x53, 0x41, 0x20, 0x43, 0x41, 0x30, 0x82, 0x02, 0x22, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x02, 0x0F, 0x00, 0x30, 0x82, 0x02, 0x0A, 0x02, 0x82, 0x02, 0x01, 0x00, 0xCC, 0x65, 0x13, 0xCE, 0x08, 0xF1, 0x49, 0x03, 0x3B, 0xDE, 0x7D, 0xDE, 0x46, 0xD3, 0x65, 0x08, 0x43, 0x2E, 0x48, 0x23, 0xE2, 0xD1, 0x01, 0x87, 0x92, 0x5D, 0xB5, 0xCF, 0xB2, 0x44, 0x5A, 0xAB, 0x69, 0xE3, 0x04, 0x59, 0x7F, 0xC2, 0xE2, 0xFC, 0xA6, 0xB9, 0xFF, 0x3F, 0xB5, 0xA0, 0x60, 0x8F, 0x5F, 0xB1, 0x3D, 0xCF, 0x98, 0x47, 0xE3, 0x7C, 0x38, 0xAB, 0x3B, 0x14, 0xD5, 0x2D, 0xD1, 0x30, 0x4A, 0x08, 0x7F, 0x67, 0x2E, 0x18, 0x5A, 0x8E, 0x4F, 0x60, 0xBA, 0x5D, 0x00, 0x8A, 0xAC, 0xDD, 0x28, 0xDE, 0xD7, 0xD9, 0xC7, 0x08, 0xED, 0x1F, 0xF9, 0x43, 0xF5, 0x6E, 0x5C, 0xD0, 0x97, 0x10, 0xC5, 0xDB, 0x33, 0x0A, 0x13, 0xB4, 0x7C, 0xD0, 0x2C, 0xF6, 0xA3, 0x83, 0xD5, 0xD2, 0x82, 0x45, 0x79, 0x6F, 0xB2, 0x1F, 0x49, 0x72, 0x56, 0x32, 0x2D, 0x30, 0x84, 0x44, 0xCC, 0x4A, 0xDE, 0xA9, 0xF8, 0xA5, 0x20, 0x59, 0xEC, 0x8E, 0x1D, 0x6E, 0xFD, 0x39, 0x71, 0xD1, 0x3D, 0xE5, 0x35, 0xD6, 0x06, 0xBC, 0x60, 0xE8, 0xCE, 0x03, 0xFC, 0x1F, 0xCF, 0x11, 0x73, 0xA6, 0xDC, 0xF8, 0xD1, 0x7D, 0x3F, 0xF4, 0x6C, 0xFD, 0x72, 0xF6, 0x64, 0x8A, 0x44, 0x88, 0xBE, 0xD6, 0x91, 0x2F, 0xFC, 0x4C, 0x18, 0xD4, 0x45, 0x2F, 0xB1, 0xF5, 0x9E, 0x6B, 0x60, 0xBD, 0xD3, 0xDC, 0xD1, 0x8F, 0x74, 0x98, 0x22, 0x33, 0x8C, 0xF5, 0x97, 0x7A, 0x48, 0x56, 0x17, 0x3C, 0x0B, 0xFA, 0x34, 0xFD, 0xE6, 0x1D, 0xB2, 0x20, 0x79, 0x88, 0x84, 0x43, 0xD0, 0xF1, 0x57, 0x69, 0xBB, 0x81, 0x9D, 0x4E, 0x3A, 0x09, 0x7A, 0x9B, 0xB2, 0xD3, 0x15, 0x03, 0xAC, 0x39, 0x76, 0x8D, 0x9C, 0xBE, 0x84, 0xF7, 0x4E, 0x29, 0xAB, 0x7E, 0x6A, 0x22, 0x15, 0xAB, 0x0F, 0xF8, 0x25, 0x7A, 0x77, 0x1D, 0x6C, 0x6E, 0x9E, 0xC4, 0xD2, 0x64, 0xEA, 0x71, 0x01, 0xFD, 0x20, 0x2D, 0x2F, 0x79, 0x54, 0x3E, 0xA9, 0x57, 0x48, 0xA5, 0x02, 0xA8, 0xFE, 0x19, 0x0D, 0x2B, 0x27, 0xE5, 0xED, 0x63, 0xE3, 0x0F, 0xD6, 0xB7, 0x93, 0x88, 0xD7, 0x08, 0xDF, 0x05, 0x9F, 0xC6, 0x0B, 0xBC, 0xC0, 0x3F, 0xB4, 0xD7, 0xDB, 0xE3, 0xFB, 0x0D, 0x71, 0x0D, 0x8C, 0x4A, 0xC5, 0x53, 0x84, 0x43, 0xAC, 0xD7, 0x34, 0xCB, 0xAC, 0xE0, 0xF2, 0xEF, 0x46, 0x84, 0xB1, 0xA1, 0x7B, 0xCA, 0x00, 0xED, 0xD1, 0x7D, 0x3D, 0xE1, 0x6C, 0xCC, 0x73, 0x78, 0x83, 0xCD, 0x07, 0xCD, 0x1F, 0x78, 0x3B, 0x8B, 0xDB, 0x76, 0x87, 0xC6, 0x8B, 0xF3, 0x37, 0x8B, 0xD9, 0xF6, 0x0C, 0xF5, 0x82, 0xB2, 0x55, 0x85, 0x0F, 0xC8, 0xDB, 0x5D, 0x6D, 0x1F, 0x19, 0xCA, 0x10, 0x78, 0x39, 0x76, 0xBD, 0x64, 0x3E, 0x42, 0x64, 0x24, 0xB7, 0x42, 0x63, 0x07, 0x35, 0xCB, 0xFD, 0x51, 0x56, 0x89, 0x38, 0x51, 0x51, 0x13, 0xEC, 0xE4, 0xF1, 0x5C, 0x6C, 0xC6, 0xC9, 0xD6, 0x0F, 0x97, 0xC5, 0xDA, 0x9D, 0x04, 0x24, 0xF0, 0x16, 0x37, 0x6F, 0xD3, 0xEF, 0x60, 0x2E, 0xAA, 0x92, 0x03, 0x41, 0x77, 0x12, 0x34, 0xCA, 0x0B, 0x18, 0x1F, 0xDB, 0xFD, 0x53, 0x48, 0x38, 0x7C, 0xA1, 0x79, 0x98, 0x46, 0x1C, 0xBA, 0x11, 0x61, 0x73, 0xF0, 0x5B, 0xB6, 0x7F, 0x7C, 0x8E, 0xE6, 0xF4, 0xFF, 0xA2, 0x78, 0xA6, 0x20, 0x51, 0x73, 0x47, 0x67, 0x4C, 0x5F, 0x04, 0x48, 0xA9, 0xB2, 0x7D, 0xD0, 0x3B, 0x50, 0xB2, 0xDD, 0xC9, 0x70, 0xFC, 0xF6, 0x64, 0x05, 0x1E, 0x5D, 0xED, 0x4A, 0xCB, 0x75, 0xF7, 0xBF, 0xF7, 0x3C, 0xAC, 0xBA, 0xDF, 0xCB, 0xEB, 0xB1, 0x23, 0x17, 0xA4, 0x41, 0x4E, 0x2A, 0xD3, 0x80, 0xD4, 0xAA, 0x3B, 0xD9, 0x9C, 0x0C, 0x0B, 0xA2, 0x8E, 0xE8, 0x56, 0x03, 0x02, 0x03, 0x01, 0x00, 0x01, 0xA3, 0x53, 0x30, 0x51, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x1D, 0x0E, 0x04, 0x16, 0x04, 0x14, 0x53, 0x40, 0xFE, 0xD2, 0x24, 0x96, 0x6A, 0x54, 0x04, 0x96, 0xA9, 0x57, 0x81, 0xA6, 0x49, 0x87, 0x43, 0xDA, 0x59, 0xA1, 0x30, 0x1F, 0x06, 0x03, 0x55, 0x1D, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14, 0x53, 0x40, 0xFE, 0xD2, 0x24, 0x96, 0x6A, 0x54, 0x04, 0x96, 0xA9, 0x57, 0x81, 0xA6, 0x49, 0x87, 0x43, 0xDA, 0x59, 0xA1, 0x30, 0x0F, 0x06, 0x03, 0x55, 0x1D, 0x13, 0x01, 0x01, 0xFF, 0x04, 0x05, 0x30, 0x03, 0x01, 0x01, 0xFF, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x0B, 0x05, 0x00, 0x03, 0x82, 0x02, 0x01, 0x00, 0x6F, 0x36, 0xE4, 0x58, 0xAA, 0xFF, 0xF1, 0xBF, 0x4C, 0x55, 0x84, 0x4B, 0x35, 0xBE, 0xFC, 0x60, 0xBF, 0xF5, 0xCC, 0xED, 0xA4, 0x64, 0x8E, 0x31, 0x68, 0x9A, 0x92, 0x03, 0x4F, 0x66, 0x4B, 0xCA, 0x4B, 0x2E, 0xFB, 0x19, 0x59, 0xE1, 0xBA, 0x12, 0xAB, 0x5C, 0xF0, 0xF2, 0xF1, 0x3B, 0x44, 0xA8, 0x66, 0xAE, 0xC3, 0x7A, 0x80, 0xA1, 0xE4, 0x31, 0xA9, 0x25, 0x87, 0x31, 0x8A, 0xEB, 0xB9, 0x72, 0x77, 0x37, 0x68, 0xF3, 0x6A, 0xF1, 0xD7, 0x5B, 0x2E, 0x71, 0x3C, 0xF0, 0x72, 0xE9, 0xDF, 0xB6, 0x12, 0xA9, 0xF2, 0x0B, 0xB4, 0xB0, 0x26, 0x04, 0x0C, 0x5D, 0x64, 0xE4, 0xB3, 0x96, 0x3D, 0xDE, 0x2E, 0x98, 0x12, 0x2E, 0x14, 0x06, 0x57, 0x12, 0x17, 0x38, 0x4F, 0x09, 0x29, 0x01, 0x56, 0xAD, 0x0B, 0xFC, 0x48, 0x18, 0x30, 0xEF, 0x70, 0x1D, 0x31, 0xDE, 0x85, 0xCA, 0xA0, 0x81, 0x43, 0x18, 0x17, 0x83, 0xEA, 0xC6, 0x2C, 0xC1, 0xFF, 0xBC, 0x8F, 0x2D, 0xE5, 0x27, 0xAC, 0xFB, 0xB5, 0x12, 0xE7, 0xBD, 0xFD, 0x5C, 0x3F, 0x8E, 0x9C, 0xED, 0xC5, 0xCD, 0x97, 0x43, 0xC9, 0x16, 0x7D, 0x3D, 0xEB, 0xD0, 0x8D, 0x08, 0xD8, 0x6A, 0x79, 0x1A, 0xCA, 0x52, 0x2B, 0xED, 0xB6, 0x5A, 0x73, 0x03, 0xFF, 0x3B, 0x26, 0x12, 0x0B, 0xF7, 0xB9, 0x72, 0x62, 0xEE, 0x4C, 0x7D, 0x2E, 0x29, 0x40, 0x52, 0xD0, 0xE5, 0x47, 0xD3, 0x33, 0x25, 0x8C, 0x32, 0xE2, 0x67, 0x85, 0xEB, 0x54, 0x43, 0xE7, 0x40, 0x2C, 0x67, 0x08, 0x4F, 0x2D, 0x14, 0xB6, 0x6C, 0x11, 0xA1, 0x6F, 0xED, 0x62, 0x67, 0x65, 0x8E, 0x43, 0xE7, 0x11, 0xA5, 0x1D, 0xAF, 0xA7, 0x16, 0xE7, 0xE7, 0xD6, 0xCB, 0xAE, 0xEA, 0x26, 0x7D, 0xA6, 0x34, 0xD7, 0x4B, 0x2A, 0x79, 0x48, 0x6C, 0xAC, 0x31, 0x3F, 0x65, 0xB6, 0x42, 0xEC, 0x65, 0xEA, 0xD6, 0x3C, 0x76, 0x61, 0xE1, 0x28, 0x26, 0x53, 0x0A, 0x0B, 0xED, 0xC9, 0xFC, 0x17, 0x20, 0xA6, 0x15, 0x93, 0xDC, 0xD3, 0x41, 0xE0, 0x0B, 0x9A, 0x3C, 0xB9, 0x51, 0x70, 0xB4, 0xD2, 0xBB, 0x61, 0xE9, 0xFD, 0x16, 0x00, 0xB4, 0xFA, 0x95, 0xB0, 0x5E, 0x4D, 0x9D, 0xC4, 0xF7, 0xDA, 0xD5, 0x70, 0x4B, 0x53, 0xAD, 0x27, 0xD7, 0x42, 0x36, 0xD3, 0xE5, 0xDB, 0xD8, 0xF3, 0x25, 0x6C, 0x31, 0x1B, 0x09, 0x2D, 0x07, 0x90, 0xB8, 0x10, 0x40, 0x30, 0x5C, 0x0D, 0xA4, 0xFF, 0xB2, 0x51, 0x86, 0xF1, 0x62, 0xEF, 0xEE, 0xE5, 0xE9, 0xF2, 0x72, 0x3D, 0x4C, 0x1A, 0xC6, 0x14, 0xBE, 0x29, 0x32, 0xB9, 0x54, 0x6D, 0xFC, 0x07, 0x22, 0x60, 0x83, 0x43, 0x88, 0xE4, 0xB3, 0x34, 0x24, 0x53, 0x8D, 0x59, 0xA6, 0x31, 0x14, 0xE3, 0x47, 0x57, 0x3E, 0xBE, 0x5A, 0xA0, 0x6B, 0x82, 0xBD, 0x3A, 0xF7, 0x08, 0x1D, 0x15, 0x45, 0xAE, 0x5B, 0xAF, 0x80, 0x0C, 0x93, 0x45, 0x80, 0xE1, 0xE9, 0xCA, 0xFD, 0xA0, 0xDF, 0x40, 0x69, 0xFC, 0xD9, 0x31, 0xFC, 0xED, 0xC2, 0x5F, 0xD2, 0x8D, 0x50, 0xF6, 0x2B, 0xCB, 0xB7, 0x4F, 0x83, 0xBA, 0xF0, 0x1F, 0x48, 0xEF, 0xF8, 0x0A, 0xDE, 0x0A, 0x80, 0x44, 0x34, 0x19, 0x00, 0xD2, 0xBB, 0xE3, 0xEB, 0x7D, 0xEF, 0x80, 0x44, 0xE2, 0x15, 0x77, 0x43, 0xAF, 0x9A, 0x7D, 0x13, 0x82, 0x06, 0x64, 0x9F, 0xCD, 0xB3, 0x61, 0xD0, 0xAF, 0x50, 0x3F, 0xAC, 0xB6, 0xE0, 0x62, 0x4D, 0xA7, 0x4B, 0xDA, 0x74, 0x6D, 0x2D, 0xB1, 0x32, 0x10, 0x07, 0x7B, 0xB9, 0x05, 0x1C, 0x76, 0x9B, 0x87, 0x9B, 0xC2, 0x25, 0x8E, 0x2F, 0x73, 0xB1, 0xF9, 0xA9, 0x32, 0xEB, 0xDC, 0x7D, 0xD6, 0xA7, 0x42, 0xA7, 0x8D, 0x0D, 0x98, 0xE0, 0x85, 0x66, 0xA2, 0xA0, 0x28, 0x09, 0x94, 0x72, 0x30, 0x82, 0x04, 0xA0, 0x30, 0x82, 0x02, 0x88, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x01, 0x01, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x0B, 0x05, 0x00, 0x30, 0x1C, 0x31, 0x1A, 0x30, 0x18, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0C, 0x11, 0x69, 0x6E, 0x74, 0x65, 0x6C, 0x20, 0x74, 0x65, 0x73, 0x74, 0x20, 0x52, 0x53, 0x41, 0x20, 0x43, 0x41, 0x30, 0x1E, 0x17, 0x0D, 0x32, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x37, 0x34, 0x35, 0x34, 0x30, 0x5A, 0x17, 0x0D, 0x33, 0x30, 0x31, 0x30, 0x30, 0x38, 0x30, 0x37, 0x34, 0x35, 0x34, 0x30, 0x5A, 0x30, 0x2B, 0x31, 0x29, 0x30, 0x27, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0C, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x6C, 0x20, 0x74, 0x65, 0x73, 0x74, 0x20, 0x52, 0x53, 0x41, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x6D, 0x65, 0x64, 0x69, 0x61, 0x74, 0x65, 0x20, 0x63, 0x65, 0x72, 0x74, 0x30, 0x82, 0x01, 0xA2, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x8F, 0x00, 0x30, 0x82, 0x01, 0x8A, 0x02, 0x82, 0x01, 0x81, 0x00, 0xCA, 0x16, 0xFF, 0x65, 0xEC, 0xCC, 0x91, 0xAB, 0xEB, 0x90, 0xC0, 0xCC, 0xC8, 0xC4, 0x7F, 0x96, 0x0E, 0x73, 0x7D, 0x55, 0x19, 0x6A, 0x72, 0x98, 0x8D, 0x0F, 0xEB, 0xB0, 0x3F, 0xAC, 0x30, 0xC4, 0x4A, 0x91, 0xFB, 0x4A, 0x8A, 0x35, 0x4B, 0x28, 0x92, 0xCB, 0x4F, 0x47, 0x18, 0x33, 0xAD, 0x14, 0x05, 0xC6, 0x86, 0x89, 0x1A, 0x06, 0x79, 0xB2, 0x77, 0xC7, 0x81, 0x3B, 0x09, 0xC3, 0x06, 0x88, 0xD9, 0xD7, 0xCC, 0xB4, 0xBD, 0x27, 0x66, 0x53, 0x6C, 0xDF, 0xE5, 0xD7, 0xAC, 0x68, 0xEC, 0x3A, 0x47, 0x2B, 0xFB, 0x32, 0x25, 0x38, 0xBD, 0xF7, 0xDF, 0xA1, 0x28, 0xCD, 0xCC, 0x04, 0xEB, 0xC2, 0xC7, 0x24, 0x9D, 0xE9, 0x86, 0x38, 0x8C, 0xC5, 0x0F, 0x26, 0xE5, 0x85, 0x4D, 0x3A, 0xBC, 0xFC, 0xE0, 0xCF, 0x5D, 0xF5, 0xDE, 0x09, 0x23, 0x99, 0xCA, 0x09, 0x8A, 0x72, 0xD9, 0x63, 0xAA, 0x75, 0xC2, 0x56, 0x53, 0x10, 0x84, 0x43, 0xBE, 0x0E, 0xC9, 0x29, 0xFD, 0x38, 0x71, 0x5D, 0x77, 0x04, 0x2E, 0x7D, 0x43, 0x5C, 0x29, 0xF7, 0xD2, 0xBE, 0x5B, 0xF2, 0xA1, 0x2A, 0x19, 0x51, 0x4D, 0x8F, 0xAE, 0x97, 0xD2, 0x17, 0x84, 0xF4, 0x64, 0x31, 0x61, 0xD7, 0x4B, 0x27, 0xA6, 0xEE, 0x93, 0xC4, 0xBC, 0x2E, 0x03, 0x68, 0xBC, 0xC8, 0x9F, 0xE3, 0x01, 0x77, 0xE5, 0xF9, 0x52, 0xB8, 0x1E, 0xBF, 0xAA, 0xD3, 0x79, 0x91, 0x13, 0x14, 0xDB, 0x23, 0x9C, 0x95, 0x47, 0x1C, 0x77, 0x84, 0x78, 0x9C, 0x63, 0xAB, 0xFD, 0x08, 0x87, 0x7A, 0x06, 0x2B, 0x06, 0xB9, 0xB5, 0xB9, 0x11, 0x42, 0x14, 0xD6, 0xBD, 0x37, 0xAF, 0x90, 0x69, 0x6F, 0x40, 0xAB, 0x45, 0xF4, 0xDD, 0x38, 0xC8, 0x2F, 0x9F, 0xE0, 0x8E, 0x5E, 0x4C, 0x49, 0x33, 0x65, 0x02, 0x34, 0x82, 0x71, 0xDC, 0xD3, 0x51, 0x07, 0x0B, 0x28, 0x39, 0x39, 0xA8, 0xAE, 0x48, 0xF2, 0x96, 0x98, 0x92, 0xB7, 0x7B, 0x79, 0x6C, 0x27, 0x4A, 0xC2, 0x68, 0xA6, 0xB5, 0x66, 0xEC, 0xEA, 0x10, 0xE9, 0xB1, 0x9A, 0xA7, 0x1C, 0xC2, 0x18, 0x24, 0xE6, 0x65, 0x9A, 0x86, 0xDD, 0x26, 0x8D, 0x0E, 0x71, 0x12, 0x24, 0x8D, 0xD7, 0x17, 0x47, 0x44, 0xF5, 0x6E, 0x0E, 0xDB, 0xBD, 0x63, 0x83, 0xA9, 0x02, 0xCD, 0xC2, 0xF6, 0x6A, 0x63, 0xD2, 0x0B, 0x74, 0x2C, 0xB8, 0x31, 0xCB, 0xD8, 0x87, 0xE6, 0x76, 0x9A, 0x60, 0x06, 0xD7, 0xB9, 0xDA, 0x26, 0x2B, 0xDF, 0x78, 0x24, 0x3B, 0x5E, 0x16, 0xE6, 0xED, 0xF7, 0x82, 0xDD, 0xB3, 0x79, 0x7F, 0xB9, 0x65, 0x03, 0xF8, 0xC9, 0x9A, 0x03, 0x0A, 0x09, 0xEB, 0x3A, 0x50, 0x62, 0x90, 0x0F, 0xE8, 0xCB, 0x31, 0x59, 0x12, 0x7D, 0x88, 0x48, 0xF4, 0x29, 0x43, 0xA3, 0x16, 0xCD, 0x5A, 0x3D, 0x91, 0x11, 0xAB, 0x02, 0x03, 0x01, 0x00, 0x01, 0xA3, 0x5E, 0x30, 0x5C, 0x30, 0x0C, 0x06, 0x03, 0x55, 0x1D, 0x13, 0x04, 0x05, 0x30, 0x03, 0x01, 0x01, 0xFF, 0x30, 0x0B, 0x06, 0x03, 0x55, 0x1D, 0x0F, 0x04, 0x04, 0x03, 0x02, 0x01, 0xFE, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x1D, 0x0E, 0x04, 0x16, 0x04, 0x14, 0x0B, 0xE2, 0x1D, 0xD7, 0xFC, 0x10, 0x86, 0xAB, 0xB6, 0xD3, 0x0E, 0xEF, 0xF7, 0xE0, 0xC4, 0x95, 0x26, 0x38, 0xC6, 0xDE, 0x30, 0x20, 0x06, 0x03, 0x55, 0x1D, 0x25, 0x01, 0x01, 0xFF, 0x04, 0x16, 0x30, 0x14, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x01, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x02, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x0B, 0x05, 0x00, 0x03, 0x82, 0x02, 0x01, 0x00, 0x92, 0x91, 0xE1, 0x08, 0x0C, 0xFF, 0x71, 0xBD, 0x6E, 0xA3, 0xBC, 0xEA, 0x12, 0xD3, 0x0E, 0xF2, 0x05, 0xEB, 0xFA, 0x19, 0x16, 0xC9, 0x08, 0x6A, 0x2D, 0x94, 0x05, 0x2E, 0x56, 0x56, 0xE3, 0xC4, 0x27, 0xC8, 0xAB, 0x9D, 0x83, 0xD2, 0x1B, 0x85, 0x33, 0x0A, 0x02, 0x2B, 0xBF, 0x05, 0x7E, 0xE7, 0xFA, 0x53, 0xD0, 0x32, 0x4D, 0x22, 0xAE, 0x74, 0x64, 0xF4, 0x0D, 0x70, 0xA5, 0x3C, 0xD5, 0xE8, 0xEE, 0x52, 0x72, 0xB7, 0x06, 0xA5, 0x0E, 0x67, 0x1E, 0x22, 0xE0, 0xA2, 0x45, 0x73, 0x7A, 0xC0, 0xF5, 0x38, 0x1C, 0xC0, 0xBB, 0xF7, 0x44, 0x20, 0x8D, 0xE1, 0x45, 0x85, 0x02, 0x2E, 0xA8, 0x85, 0x13, 0x5C, 0x73, 0xAC, 0x45, 0x72, 0x74, 0xB8, 0xA5, 0x0E, 0x7B, 0xD3, 0x8E, 0x91, 0x76, 0x69, 0x69, 0x89, 0xF4, 0xDF, 0x24, 0xB8, 0x11, 0x64, 0x19, 0x26, 0xE6, 0x84, 0x95, 0x8A, 0xE1, 0x39, 0x1D, 0xA4, 0x2A, 0x1C, 0x0B, 0x93, 0x94, 0x52, 0xDB, 0xA7, 0xDA, 0xAB, 0x84, 0x52, 0x8D, 0x53, 0x8B, 0x80, 0x0B, 0x26, 0xA5, 0x88, 0x9D, 0x94, 0xA0, 0x2A, 0x2D, 0x7B, 0xB0, 0x05, 0x80, 0x96, 0x69, 0x25, 0xCE, 0x6B, 0xF6, 0x94, 0xF6, 0xDD, 0xFE, 0xC9, 0xAF, 0x0B, 0x7C, 0xF1, 0xF1, 0x9B, 0x3A, 0xD0, 0x48, 0x16, 0x59, 0x7D, 0xC0, 0x1A, 0xCB, 0xC8, 0xF0, 0xB6, 0x17, 0x5D, 0x10, 0x07, 0x16, 0x3E, 0x4D, 0x36, 0x4E, 0x2A, 0x92, 0xE6, 0x00, 0xFE, 0x9A, 0xBB, 0x6D, 0x7B, 0xCE, 0x7F, 0x64, 0x61, 0x0C, 0x89, 0x1D, 0xA4, 0x24, 0xCC, 0x8A, 0xBE, 0xF6, 0xB4, 0x28, 0xEE, 0x8C, 0x1F, 0xF2, 0x7D, 0xA1, 0x71, 0x3C, 0xD8, 0xA3, 0x98, 0xBA, 0x4F, 0x34, 0x06, 0x22, 0x95, 0xE0, 0xE3, 0x51, 0xDE, 0xFF, 0xA6, 0x0F, 0x33, 0xCA, 0xB4, 0x39, 0x99, 0xA3, 0x99, 0x8B, 0xA8, 0xF5, 0x81, 0xA8, 0x2C, 0xEF, 0x26, 0xE9, 0xE2, 0x4B, 0x9A, 0xD9, 0x89, 0xC4, 0xBF, 0x8D, 0xD1, 0x10, 0x72, 0x40, 0x26, 0xB4, 0x46, 0x49, 0x10, 0xFF, 0x00, 0x56, 0xA1, 0x0A, 0xCC, 0xD1, 0x18, 0xE6, 0xC8, 0x89, 0x34, 0x0B, 0x9E, 0x25, 0x06, 0x2A, 0x35, 0x56, 0x7D, 0x14, 0xB4, 0xF4, 0x8B, 0x66, 0x92, 0xC6, 0xCA, 0xE9, 0xB6, 0x17, 0x17, 0xCD, 0x4C, 0x23, 0x7C, 0x04, 0xBD, 0x1B, 0xF3, 0x4F, 0x7B, 0xC3, 0xCA, 0xB6, 0x9A, 0x60, 0xF7, 0xED, 0xD1, 0xD7, 0x74, 0x02, 0xE8, 0x9D, 0xD1, 0x29, 0x99, 0x61, 0x88, 0x67, 0xCC, 0xCD, 0x53, 0xD0, 0xDB, 0x6D, 0x4D, 0x3F, 0xC4, 0x26, 0xB8, 0x7A, 0x68, 0xAB, 0x0D, 0xCC, 0x71, 0x55, 0x18, 0x5F, 0x26, 0xC7, 0x6A, 0x0A, 0x5B, 0xDE, 0x6F, 0x13, 0x83, 0x27, 0x47, 0xFC, 0xE2, 0x2E, 0xC9, 0x64, 0x8D, 0x42, 0xD0, 0xC1, 0xB2, 0xFF, 0xC5, 0x46, 0xC0, 0xF0, 0x09, 0x62, 0x74, 0xAD, 0x56, 0x49, 0xD2, 0xF7, 0x1E, 0xC8, 0x52, 0x5B, 0x56, 0x72, 0xCE, 0x16, 0x98, 0xEE, 0xDB, 0x5E, 0xD4, 0x08, 0xEA, 0x10, 0x11, 0x7B, 0x2B, 0xC8, 0x84, 0xFE, 0xC1, 0xB2, 0x60, 0xFA, 0x6A, 0x7F, 0xFA, 0x8A, 0x59, 0xE0, 0x02, 0x5E, 0xB7, 0x23, 0xF5, 0x99, 0x99, 0xAE, 0x96, 0x7D, 0x98, 0x0A, 0x6A, 0x46, 0x0C, 0x54, 0x79, 0xD5, 0x5D, 0x14, 0x25, 0xC1, 0xD0, 0x13, 0xD3, 0x09, 0xA1, 0xDB, 0x40, 0xC0, 0x77, 0x81, 0x7C, 0x4C, 0x48, 0x66, 0x5D, 0x60, 0x1A, 0x02, 0x4E, 0x03, 0xA1, 0x7D, 0xE3, 0x31, 0xEA, 0xCC, 0xD2, 0x3D, 0xC9, 0x27, 0xE6, 0x5C, 0x63, 0xB2, 0x75, 0xD2, 0x8D, 0x57, 0xE2, 0x7F, 0x57, 0xEF, 0xF0, 0x56, 0x30, 0x5E, 0x86, 0x70, 0x0C, 0x94, 0xCB, 0x33, 0x0D, 0x06, 0xB3, 0xDB, 0x69, 0x12, 0x5F, 0x89, 0xB8, 0xD9, 0xBB, 0x0A, 0xBB, 0x30, 0x82, 0x04, 0x6B, 0x30, 0x82, 0x02, 0xD3, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x01, 0x02, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x0B, 0x05, 0x00, 0x30, 0x2B, 0x31, 0x29, 0x30, 0x27, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0C, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x6C, 0x20, 0x74, 0x65, 0x73, 0x74, 0x20, 0x52, 0x53, 0x41, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x6D, 0x65, 0x64, 0x69, 0x61, 0x74, 0x65, 0x20, 0x63, 0x65, 0x72, 0x74, 0x30, 0x1E, 0x17, 0x0D, 0x32, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x37, 0x34, 0x35, 0x34, 0x30, 0x5A, 0x17, 0x0D, 0x32, 0x31, 0x31, 0x30, 0x31, 0x30, 0x30, 0x37, 0x34, 0x35, 0x34, 0x30, 0x5A, 0x30, 0x28, 0x31, 0x26, 0x30, 0x24, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0C, 0x1D, 0x69, 0x6E, 0x74, 0x65, 0x6C, 0x20, 0x74, 0x65, 0x73, 0x74, 0x20, 0x52, 0x53, 0x41, 0x20, 0x72, 0x65, 0x71, 0x75, 0x73, 0x65, 0x74, 0x65, 0x72, 0x20, 0x63, 0x65, 0x72, 0x74, 0x30, 0x82, 0x01, 0xA2, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x8F, 0x00, 0x30, 0x82, 0x01, 0x8A, 0x02, 0x82, 0x01, 0x81, 0x00, 0xC8, 0xC2, 0x62, 0x41, 0x2C, 0x2E, 0x53, 0x1E, 0x1C, 0x1F, 0x67, 0xBE, 0x50, 0xA8, 0x0E, 0x48, 0x67, 0x9B, 0x48, 0x29, 0xF9, 0xE3, 0x5E, 0x28, 0x54, 0x5E, 0xD1, 0x92, 0x90, 0x6A, 0xD4, 0xF2, 0xE6, 0xE4, 0xE5, 0x5F, 0x34, 0xD4, 0x14, 0xB9, 0x36, 0xC9, 0x36, 0xC3, 0x58, 0x5C, 0xAF, 0x1A, 0x83, 0x26, 0x93, 0xC3, 0x5D, 0x6F, 0xE4, 0xA0, 0xE1, 0xE4, 0xFF, 0xB5, 0x23, 0x39, 0xE6, 0xE8, 0x63, 0xB5, 0x95, 0x3C, 0xB2, 0xF2, 0x05, 0x60, 0x56, 0xA3, 0x2A, 0x0F, 0x37, 0x32, 0xD1, 0x77, 0xD6, 0x8D, 0x7F, 0x4D, 0x22, 0xA1, 0xE5, 0xFC, 0x4E, 0xF6, 0xBF, 0xE0, 0x90, 0x55, 0x06, 0x42, 0xBA, 0xB0, 0x6E, 0x23, 0xBE, 0x85, 0x74, 0xAB, 0xDF, 0xA6, 0x43, 0x5E, 0x3C, 0x32, 0x6D, 0x31, 0xD5, 0xE9, 0xE2, 0x9C, 0x80, 0xE9, 0xA7, 0x37, 0xCF, 0x0D, 0xD0, 0x73, 0x1B, 0xF4, 0x66, 0xA6, 0x72, 0x54, 0x44, 0xA7, 0x22, 0xAB, 0x9E, 0x3E, 0xB8, 0xB9, 0x46, 0x38, 0xB8, 0x83, 0x4A, 0x48, 0x23, 0x7C, 0x60, 0x20, 0x91, 0x7E, 0x1D, 0x36, 0x9E, 0x46, 0x71, 0xFE, 0xFC, 0x51, 0xBA, 0x7F, 0x58, 0xEB, 0xCB, 0xC0, 0x52, 0xF8, 0x0F, 0xD8, 0x97, 0x54, 0x38, 0xDB, 0x5C, 0x93, 0x4F, 0xF8, 0x22, 0xCB, 0x2D, 0x11, 0x2B, 0xE8, 0x54, 0x1A, 0x88, 0xD2, 0x9E, 0xEC, 0x71, 0x2A, 0x3D, 0x9A, 0x14, 0x39, 0x7D, 0x3C, 0x2B, 0x4F, 0x49, 0x4E, 0xDC, 0x41, 0xA5, 0xDB, 0x01, 0x0C, 0x1F, 0x70, 0xA0, 0xAE, 0x8B, 0x5A, 0x11, 0x9A, 0xE4, 0xE4, 0xD9, 0x9D, 0x86, 0x28, 0x05, 0x43, 0x23, 0xA4, 0xD6, 0x3A, 0xA4, 0xE7, 0x78, 0x2C, 0x9F, 0x80, 0x8A, 0xF7, 0xC4, 0x34, 0xD5, 0x57, 0xEE, 0x6A, 0xFA, 0x2D, 0x40, 0xCE, 0xEC, 0xA9, 0xFF, 0x58, 0xCD, 0x01, 0xE2, 0x04, 0x50, 0x1D, 0xE6, 0xB6, 0x3F, 0x9E, 0x34, 0xD2, 0x66, 0x57, 0xBB, 0x8A, 0x55, 0x86, 0x29, 0x47, 0x44, 0x3F, 0x21, 0xC3, 0x04, 0x28, 0xBF, 0x9C, 0x62, 0x7A, 0xF0, 0x6C, 0x90, 0x8C, 0xF9, 0x97, 0x70, 0x41, 0x6C, 0xB1, 0xDE, 0x5E, 0x04, 0xED, 0xD6, 0x3B, 0x06, 0xC3, 0x0F, 0x41, 0xD9, 0x79, 0xDE, 0x11, 0xFB, 0x25, 0xFA, 0xDE, 0xCA, 0x64, 0xC8, 0x4D, 0xB9, 0xB0, 0xAD, 0x38, 0x97, 0x0A, 0x64, 0xC9, 0xF5, 0x74, 0xF2, 0xD1, 0xBE, 0xCC, 0x5C, 0x0B, 0x6F, 0xA8, 0x9D, 0x44, 0x30, 0x67, 0x84, 0x23, 0x79, 0xB5, 0xC1, 0xCD, 0x56, 0xB9, 0x54, 0x57, 0x0E, 0x84, 0xC2, 0x11, 0xFA, 0x13, 0x79, 0x2C, 0x3A, 0x2F, 0xAD, 0xDA, 0x86, 0xAA, 0x82, 0xD0, 0x99, 0x00, 0xFF, 0x07, 0x11, 0x20, 0x86, 0x16, 0x2D, 0x58, 0xA2, 0xDB, 0x86, 0xCF, 0xDB, 0x50, 0x18, 0x62, 0x82, 0x72, 0xA2, 0xF1, 0xD3, 0x46, 0x3A, 0x3B, 0x02, 0x03, 0x01, 0x00, 0x01, 0xA3, 0x81, 0x9C, 0x30, 0x81, 0x99, 0x30, 0x0C, 0x06, 0x03, 0x55, 0x1D, 0x13, 0x01, 0x01, 0xFF, 0x04, 0x02, 0x30, 0x00, 0x30, 0x0B, 0x06, 0x03, 0x55, 0x1D, 0x0F, 0x04, 0x04, 0x03, 0x02, 0x05, 0xE0, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x1D, 0x0E, 0x04, 0x16, 0x04, 0x14, 0x86, 0x5A, 0xD2, 0xBB, 0x45, 0xF7, 0x2A, 0x0F, 0xD6, 0x20, 0x29, 0x89, 0x7E, 0x82, 0xAF, 0x29, 0x6B, 0xF6, 0x42, 0xCB, 0x30, 0x31, 0x06, 0x03, 0x55, 0x1D, 0x11, 0x04, 0x2A, 0x30, 0x28, 0xA0, 0x26, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x83, 0x1C, 0x82, 0x12, 0x01, 0xA0, 0x18, 0x0C, 0x16, 0x41, 0x43, 0x4D, 0x45, 0x3A, 0x57, 0x49, 0x44, 0x47, 0x45, 0x54, 0x3A, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x30, 0x2A, 0x06, 0x03, 0x55, 0x1D, 0x25, 0x01, 0x01, 0xFF, 0x04, 0x20, 0x30, 0x1E, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x01, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x02, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x09, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x0B, 0x05, 0x00, 0x03, 0x82, 0x01, 0x81, 0x00, 0x35, 0x6B, 0x78, 0xE5, 0xE2, 0xC8, 0xAC, 0x49, 0x71, 0x24, 0xCB, 0x43, 0x5A, 0x47, 0x40, 0x01, 0xEC, 0x69, 0xEE, 0xBA, 0xBB, 0x58, 0x17, 0x95, 0x3A, 0x38, 0x61, 0x01, 0xB2, 0xB3, 0x83, 0xE5, 0xBD, 0xE5, 0xED, 0xA0, 0xD0, 0xAF, 0x62, 0x6A, 0x3C, 0xE4, 0x6E, 0xF1, 0x3A, 0x7E, 0xCD, 0x94, 0x32, 0x39, 0xBC, 0x51, 0x23, 0xE1, 0x3B, 0xC2, 0xA8, 0xA6, 0x08, 0xA8, 0xD0, 0xD5, 0x58, 0xFC, 0x4C, 0x0A, 0xE7, 0xAE, 0x5C, 0x98, 0x45, 0xC7, 0xDB, 0x11, 0x4E, 0x59, 0x5A, 0xBF, 0x13, 0x2A, 0xF9, 0x57, 0x91, 0xE6, 0x9A, 0xBD, 0x82, 0x48, 0x95, 0x1A, 0xE3, 0x87, 0x1E, 0x66, 0x55, 0xC9, 0x0F, 0x41, 0x07, 0x82, 0xB5, 0xF8, 0xBB, 0xBD, 0xEA, 0x38, 0x9B, 0x42, 0x34, 0x5E, 0xBC, 0x72, 0x91, 0x61, 0x76, 0x7B, 0x1A, 0xB2, 0xCB, 0x04, 0x70, 0x0D, 0x35, 0xC2, 0xAC, 0xE9, 0xE8, 0x65, 0x3D, 0x61, 0x9D, 0x43, 0x4A, 0x5E, 0xA6, 0x41, 0xCC, 0x67, 0x45, 0xB9, 0x2B, 0x35, 0x90, 0x21, 0x1C, 0x14, 0xA0, 0x55, 0x08, 0x11, 0x8C, 0x74, 0x3C, 0xCD, 0x7F, 0xB3, 0x20, 0x7F, 0x5C, 0x8F, 0x40, 0x5C, 0x57, 0xA7, 0xCC, 0xC5, 0x50, 0x0E, 0x8C, 0xE4, 0x39, 0xBF, 0x4F, 0xD8, 0x59, 0x8E, 0x16, 0x20, 0x2B, 0x2B, 0x3B, 0x32, 0xF0, 0x05, 0xB7, 0x1D, 0x31, 0x4A, 0xFD, 0x32, 0x31, 0x1F, 0x1F, 0x06, 0xF8, 0x91, 0x7D, 0x1F, 0x43, 0xA0, 0x74, 0x7D, 0xEC, 0x19, 0x19, 0x4A, 0x8C, 0xAA, 0x01, 0x02, 0x93, 0x7F, 0x88, 0xA1, 0x10, 0x29, 0x38, 0x66, 0x90, 0x3E, 0xD5, 0x3B, 0x69, 0x5A, 0x36, 0x98, 0x5F, 0x81, 0xC3, 0x0F, 0xB3, 0xC5, 0x25, 0xBA, 0xC4, 0x11, 0x84, 0xEE, 0xC7, 0x28, 0xD0, 0xB7, 0x74, 0x6D, 0xB7, 0x58, 0xBB, 0x87, 0x90, 0xDB, 0x6E, 0x2D, 0xFC, 0xEC, 0x23, 0xDA, 0x71, 0xA1, 0x27, 0xC0, 0xE8, 0xB0, 0x75, 0x4F, 0x5C, 0x22, 0x20, 0x3D, 0xB7, 0x3B, 0x18, 0xD7, 0x03, 0xE0, 0x12, 0xA1, 0x8E, 0x9D, 0x26, 0x91, 0x38, 0x1A, 0x1A, 0xFF, 0x52, 0xB1, 0x63, 0xD7, 0x2F, 0xFF, 0x3B, 0x96, 0x65, 0xB1, 0x05, 0xB6, 0x70, 0x5D, 0x8D, 0xFC, 0xDC, 0x19, 0x0A, 0x50, 0xCB, 0x1B, 0xA7, 0xE0, 0xF3, 0xA2, 0xEA, 0xFB, 0x28, 0x7B, 0x26, 0x66, 0x0C, 0xEC, 0x13, 0xD1, 0x54, 0x94, 0x6C, 0xD9, 0xE3, 0xCF, 0xDC, 0xCE, 0x32, 0x73, 0xD3, 0x09, 0x55, 0x61, 0x5A, 0xFA, 0x84, 0x0F, 0x55, 0x7B, 0x93, 0xB6, 0x60, 0x19, 0x0D, 0x37, 0x89, 0xC1, 0x14, 0x02, 0x81, 0xDF, 0x52, 0x42, 0xBD, 0x6D, 0xD8, 0x45, 0xAF, 0x5B, 0x38, 0xA5, 0x00, 0x5A, 0x84, 0x0C, 0xFC, 0x60, 0xF3, 0x70, 0xA6, 0x7A, 0x54, 0x44, 0xC2, 0x34, 0xAA, 0xC6, 0x76, 0x51, 0x1E, 0xD3, 0x9D, 0x83 };
+#endif /* CONFIG_SPDM */
+
 struct virtio_blk_priv {
 	struct virtqueue *vq;
 };
 
+// #if CONFIG_IS_ENABLED(SPDM)
+// #define SPDM_CTX_TO_VIRTIOBLK(spdm_context_ptr) *(struct blk_desc**)((char*)(spdm_context_ptr) + spdm_get_context_size())
+// #endif
+
 static ulong virtio_blk_do_req(struct udevice *dev, u64 sector,
 			       lbaint_t blkcnt, void *buffer, u32 type)
 {
@@ -27,13 +48,15 @@ static ulong virtio_blk_do_req(struct udevice *dev, u64 sector,
 	struct virtio_sg *sgs[3];
 	u8 status;
 	int ret;
+	lbaint_t size = (type & VIRTIO_BLK_T_SPDM) ? blkcnt : blkcnt * 512;
+	lbaint_t temp_size;
 
 	struct virtio_blk_outhdr out_hdr = {
 		.type = cpu_to_virtio32(dev, type),
 		.sector = cpu_to_virtio64(dev, sector),
 	};
 	struct virtio_sg hdr_sg = { &out_hdr, sizeof(out_hdr) };
-	struct virtio_sg data_sg = { buffer, blkcnt * 512 };
+	struct virtio_sg data_sg = { buffer, size };
 	struct virtio_sg status_sg = { &status, sizeof(status) };
 
 	sgs[num_out++] = &hdr_sg;
@@ -44,8 +67,8 @@ static ulong virtio_blk_do_req(struct udevice *dev, u64 sector,
 		sgs[num_out + num_in++] = &data_sg;
 
 	sgs[num_out + num_in++] = &status_sg;
-	log_debug("dev=%s, active=%d, priv=%p, priv->vq=%p\n", dev->name,
-		  device_active(dev), priv, priv->vq);
+	// log_warning("dev=%s, active=%d, priv=%p, priv->vq=%p\n", dev->name,
+	// 	  device_active(dev), priv, priv->vq);
 
 	ret = virtqueue_add(priv->vq, sgs, num_out, num_in);
 	if (ret)
@@ -53,18 +76,33 @@ static ulong virtio_blk_do_req(struct udevice *dev, u64 sector,
 
 	virtqueue_kick(priv->vq);
 
-	log_debug("wait...");
+	// log_warning("wait...");
 	while (!virtqueue_get_buf(priv->vq, NULL))
 		;
-	log_debug("done\n");
+	// log_warning("done\n");
+
+	if (type & VIRTIO_BLK_T_SPDM) {
+		temp_size = * ((u32*) (buffer+1));
+		if (temp_size  > size) {
+			ret = -1;
+			size = 0;
+			return ret;
+		}
+		size = temp_size;
+
+		// magic number: assuming 1-byte message type and 4-byte message size
+		memmove (buffer, buffer + 5, size);
 
-	return status == VIRTIO_BLK_S_OK ? blkcnt : -EIO;
+		return status == VIRTIO_BLK_S_OK ? size : -EIO;
+	} else {
+		return status == VIRTIO_BLK_S_OK ? blkcnt : -EIO;
+	}
 }
 
 static ulong virtio_blk_read(struct udevice *dev, lbaint_t start,
 			     lbaint_t blkcnt, void *buffer)
 {
-	log_debug("read %s\n", dev->name);
+	// log_debug("read %s\n", dev->name);
 	return virtio_blk_do_req(dev, start, blkcnt, buffer,
 				 VIRTIO_BLK_T_IN);
 }
@@ -116,6 +154,12 @@ static int virtio_blk_probe(struct udevice *dev)
 	struct blk_desc *desc = dev_get_uclass_plat(dev);
 	u64 cap;
 	int ret;
+#if CONFIG_IS_ENABLED(SPDM)
+	return_status status;
+	boolean use_psk;
+	uint8 heartbeat_period;
+	uint8 measurement_hash[MAX_HASH_SIZE];
+#endif
 
 	ret = virtio_find_vqs(dev, 1, &priv->vq);
 	if (ret)
@@ -126,8 +170,620 @@ static int virtio_blk_probe(struct udevice *dev)
 	virtio_cread(dev, struct virtio_blk_config, capacity, &cap);
 	desc->lba = cap;
 
+#if CONFIG_IS_ENABLED(SPDM)
+	desc->spdm_context = virtblk_init_spdm();
+	if (desc->spdm_context == NULL) {
+		log_err("[SPDM @ U-Boot]: SPDM context is NULL.\n");
+		status = -1;
+		goto out;
+	}
+	// hack to be able to access vblk if we only have the context
+	SPDM_CTX_TO_VIRTIOBLK(desc->spdm_context) = desc;
+	/**
+	 * ! HARD CODED
+	 */
+	// buffer = malloc(sizeof(void*)*64);
+	// virtio_blk_do_req(dev, 0, 5, get_version, VIRTIO_BLK_T_SPDM | VIRTIO_BLK_T_OUT);
+	// virtio_blk_do_req(dev, 0, 17, buffer, VIRTIO_BLK_T_SPDM);
+	// for (int i = 0; i < 11; i++) {
+	// 	log_warning("%02X ", ((uint8_t*)buffer)[i+5]);
+	// }
+	// log_warning("\n");
+
+	// virtio_blk_do_req(dev, 0, 13, get_capabilities, VIRTIO_BLK_T_SPDM | VIRTIO_BLK_T_OUT);
+	// virtio_blk_do_req(dev, 0, 18, buffer, VIRTIO_BLK_T_SPDM);
+	// for (int i = 0; i < 13; i++) {
+	// 	log_warning("%02X ", ((uint8_t*)buffer)[i+5]);
+	// }
+	// log_warning("\n");
+
+	// virtio_blk_do_req(dev, 0, 49, get_algorithms, VIRTIO_BLK_T_SPDM | VIRTIO_BLK_T_OUT);
+	// virtio_blk_do_req(dev, 0, 58, buffer, VIRTIO_BLK_T_SPDM);
+	// for (int i = 0; i < 17; i++) {
+	// 	log_warning("%02X ", ((uint8_t*)buffer)[i+5]);
+	// }
+	// log_warning("\n");
+
+	// return spdm_test(desc->spdm_context);
+
+	/**
+	 * ! Nice Way
+	 */
+	status = spdm_init_connection(
+		desc->spdm_context,
+		(m_exe_connection & EXE_CONNECTION_VERSION_ONLY) != 0
+		);
+	if (RETURN_ERROR(status)) {
+		log_err("[SPDM @ U-Boot]: Error initializing SPDM connection: 0x%llx.\n", status);
+		goto out_free_spdm;
+	} else {
+		log_warning("[SPDM @ U-Boot]: SPDM connection initialized.\n");
+	}
+
+	virtblk_init_spdm_certificates(desc->spdm_context);
+
+	status = do_authentication_via_spdm(desc->spdm_context);
+	if (RETURN_ERROR(status)) {
+		log_err(
+			"[SPDM @ U-Boot]: Error authenticating via SPDM.\n"
+			"\tStatus 0x%02X\n",
+			(u32)status
+			);
+		goto out_free_spdm;
+	} else {
+		log_warning("[SPDM @ U-Boot]: Authenticated via SPDM.\n");
+	}
+
+	use_psk = FALSE;
+	heartbeat_period = 0;
+	desc->session_id = 0;
+	status = spdm_start_session(
+						desc->spdm_context,
+						use_psk,
+				    m_use_measurement_summary_hash_type,
+				    m_use_slot_id,
+						&desc->session_id,
+				    &heartbeat_period,
+						measurement_hash
+						);
+	if (RETURN_ERROR(status)) {
+		log_warning("[SPDM @ U-Boot]: Error starting SPDM session 0x%02X.\n", (uint32)status);
+		goto out_free_spdm;
+	} else {
+		log_warning("[SPDM @ U-Boot]: Started SPDM session.\n");
+	}
+#endif
+
 	return 0;
+
+out_free_spdm:
+	free(desc->spdm_context);
+out:
+	return status;
+}
+
+#if CONFIG_IS_ENABLED(SPDM)
+return_status spdm_virtblk_send_message(
+	IN void		*spdm_context,
+	IN uintn	request_size,
+	IN void		*request,
+	IN uint64 timeout
+)
+{
+	struct blk_desc* desc;
+	ulong status;
+	desc = SPDM_CTX_TO_VIRTIOBLK(spdm_context);
+	if (!desc)
+		return RETURN_DEVICE_ERROR;
+
+#if BLK_SPDM_DEBUG
+	log_warning("[SPDM @ U-Boot]: Sending message of size %llu\n", request_size);
+	for (int i = 0; i < request_size; i++) {
+		log_warning("%02X ", ((uint8_t*)request)[i]);
+	}
+	log_warning("\n\n");
+#endif
+	status = virtio_blk_do_req(desc->bdev, 0, (lbaint_t)request_size, request, VIRTIO_BLK_T_SPDM | VIRTIO_BLK_T_OUT);
+
+	return RETURN_SUCCESS;
+}
+
+return_status spdm_virtblk_receive_message(
+	IN 			void		*spdm_context,
+	IN OUT 	uintn		*response_size,
+	IN OUT 	void		*response,
+	IN 			uint64	timeout
+)
+{
+	struct blk_desc *desc;
+
+	desc = SPDM_CTX_TO_VIRTIOBLK(spdm_context);
+	if (!desc)
+		return RETURN_DEVICE_ERROR;
+
+	*response_size = virtio_blk_do_req(desc->bdev, 0, *response_size, response, VIRTIO_BLK_T_SPDM | VIRTIO_BLK_T_IN);
+
+#if BLK_SPDM_DEBUG
+	log_warning("[SPDM @ U-Boot]: Receiving message of size %llu\n", *response_size);
+	for (uint8_t i = 0; i < 17; i++) {
+		log_warning("%02X ", ((uint8_t*)response)[i]);
+	}
+	log_warning("\n\n");
+#endif
+	return RETURN_SUCCESS;
+}
+
+void* virtblk_init_spdm(void)
+{
+	spdm_context_t *spdm_context;
+	spdm_data_parameter_t parameter;
+	u8 data8;
+	u16 data16;
+	u32 data32;
+	spdm_version_number_t spdm_version;
+
+	spdm_context = malloc(spdm_get_context_size()+sizeof(void*));
+	if (spdm_context == NULL)
+		return NULL;
+
+	spdm_init_context(spdm_context);
+	spdm_register_device_io_func(
+		spdm_context,
+		spdm_virtblk_send_message,
+		spdm_virtblk_receive_message
+		);
+	
+	if (m_use_transport_layer == SOCKET_TRANSPORT_TYPE_MCTP) {
+		spdm_register_transport_layer_func(
+			spdm_context,
+			spdm_transport_mctp_encode_message,
+			spdm_transport_mctp_decode_message
+			);
+	} else {
+		free(spdm_context);
+		return NULL;
+	}
+
+	if (m_use_version != SPDM_MESSAGE_VERSION_11) {
+		zero_mem(&parameter, sizeof(parameter));
+		parameter.location = SPDM_DATA_LOCATION_LOCAL;
+		spdm_version.major_version = (m_use_version >> 4) & 0xF;
+		spdm_version.minor_version = m_use_version & 0xF;
+		spdm_version.alpha = 0;
+		spdm_version.update_version_number = 0;
+		spdm_set_data(
+			spdm_context,
+			SPDM_DATA_SPDM_VERSION,
+			&parameter,
+			&spdm_version,
+			sizeof(spdm_version)
+			);
+	} 
+
+	if (m_use_secured_message_version != SPDM_MESSAGE_VERSION_11) {
+		zero_mem(&parameter, sizeof(parameter));
+		if (m_use_secured_message_version != 0) {
+			parameter.location = SPDM_DATA_LOCATION_LOCAL;
+			spdm_version.major_version =
+				(m_use_secured_message_version >> 4) & 0xF;
+			spdm_version.minor_version =
+				m_use_secured_message_version & 0xF;
+			spdm_version.alpha = 0;
+			spdm_version.update_version_number = 0;
+			spdm_set_data(
+				spdm_context,
+				SPDM_DATA_SECURED_MESSAGE_VERSION,
+				&parameter,
+				&spdm_version,
+				sizeof(spdm_version)
+				);
+		} else {
+			spdm_set_data(
+				spdm_context,
+				SPDM_DATA_SECURED_MESSAGE_VERSION,
+				&parameter,
+				NULL,
+				0
+				);
+		}
+	}
+
+	zero_mem(&parameter, sizeof(parameter));
+	parameter.location = SPDM_DATA_LOCATION_LOCAL;
+
+	data8 = 0;
+	spdm_set_data(
+		spdm_context,
+		SPDM_DATA_CAPABILITY_CT_EXPONENT,
+		&parameter,
+		&data8,
+		sizeof(data8)
+		);
+	data32 = m_use_requester_capability_flags;
+	if (m_use_capability_flags != 0) {
+		data32 = m_use_capability_flags;
+	}
+	spdm_set_data(
+		spdm_context,
+		SPDM_DATA_CAPABILITY_FLAGS,
+		&parameter,
+		&data32,
+		sizeof(data32)
+		);
+
+	data8 = m_support_measurement_spec;
+	spdm_set_data(
+		spdm_context,
+		SPDM_DATA_MEASUREMENT_SPEC,
+		&parameter,
+		&data8,
+		sizeof(data8)
+		);
+	data32 = m_support_asym_algo;
+	spdm_set_data(
+		spdm_context,
+		SPDM_DATA_BASE_ASYM_ALGO,
+		&parameter,
+		&data32,
+		sizeof(data32)
+		);
+	data32 = m_support_hash_algo;
+	spdm_set_data(
+		spdm_context,
+		SPDM_DATA_BASE_HASH_ALGO,
+		&parameter,
+		&data32,
+		sizeof(data32)
+		);
+	data16 = m_support_dhe_algo;
+	spdm_set_data(
+		spdm_context,
+		SPDM_DATA_DHE_NAME_GROUP,
+		&parameter,
+		&data16,
+		sizeof(data16)
+		);
+	data16 = m_support_aead_algo;
+	spdm_set_data(
+		spdm_context,
+		SPDM_DATA_AEAD_CIPHER_SUITE,
+		&parameter,
+		&data16,
+		sizeof(data16)
+		);
+	data16 = m_support_req_asym_algo;
+	spdm_set_data(
+		spdm_context,
+		SPDM_DATA_REQ_BASE_ASYM_ALG,
+		&parameter,
+		&data16,
+		sizeof(data16)
+		);
+
+	data16 = m_support_key_schedule_algo;
+	spdm_set_data(
+		spdm_context,
+		SPDM_DATA_KEY_SCHEDULE,
+		&parameter,
+		&data16,
+		sizeof(data16)
+		);
+
+	return spdm_context;
+}
+
+void virtblk_init_spdm_certificates(void* spdm_context)
+{
+	uint8 index;
+	return_status status;
+	// boolean res;
+	// void *data;
+	uintn data_size;
+	spdm_data_parameter_t parameter;
+	uint8 data8;
+	uint16 data16;
+	uint32 data32;
+	// void *hash;
+	// uintn hash_size;
+
+	zero_mem(&parameter, sizeof(parameter));
+	parameter.location = SPDM_DATA_LOCATION_CONNECTION;
+
+	data_size = sizeof(data32);
+	spdm_get_data(
+		spdm_context,
+		SPDM_DATA_CONNECTION_STATE,
+		&parameter,
+		&data32,
+		&data_size
+		);
+	ASSERT(data32 == SPDM_CONNECTION_STATE_NEGOTIATED);
+
+	data_size = sizeof(data32);
+	spdm_get_data(
+		spdm_context,
+		SPDM_DATA_MEASUREMENT_HASH_ALGO,
+		&parameter,
+		&data32,
+		&data_size
+		);
+	m_use_measurement_hash_algo = data32;
+	data_size = sizeof(data32);
+	spdm_get_data(
+		spdm_context,
+		SPDM_DATA_BASE_ASYM_ALGO,
+		&parameter,
+		&data32,
+		&data_size
+		);
+	m_use_asym_algo = data32;
+	data_size = sizeof(data32);
+	spdm_get_data(
+		spdm_context,
+		SPDM_DATA_BASE_HASH_ALGO,
+		&parameter,
+		&data32,
+		&data_size
+		);
+	m_use_hash_algo = data32;
+	data_size = sizeof(data16);
+	spdm_get_data(
+		spdm_context,
+		SPDM_DATA_REQ_BASE_ASYM_ALG,
+		&parameter,
+		&data16,
+		&data_size);
+	m_use_req_asym_algo = data16;
+
+	// printf("read_responder_public_certificate_chain\n");
+	if ((m_use_slot_id == 0xFF) ||
+	    ((m_use_requester_capability_flags &
+	      SPDM_GET_CAPABILITIES_REQUEST_FLAGS_PUB_KEY_ID_CAP) != 0)) {
+		// res = read_responder_public_certificate_chain(m_use_hash_algo,
+		// 					      m_use_asym_algo,
+		// 					      &data, &data_size,
+		// 					      NULL, NULL);
+		// res = false; // We do not support this use case (public key of the Responder provisioned to the Requester previously)
+		// if (!res) {
+		// 	res = true;
+		// 	data = responder_public_certificate_chain_data;
+		// 	data_size = responder_public_certificate_chain_size;
+		// }
+		// if (res) {
+			zero_mem(&parameter, sizeof(parameter));
+			parameter.location = SPDM_DATA_LOCATION_LOCAL;
+			spdm_set_data(
+				spdm_context,
+				SPDM_DATA_PEER_PUBLIC_CERT_CHAIN,
+				&parameter,
+				responder_public_certificate_chain_data,
+				responder_public_certificate_chain_size
+				);
+			// Do not free it.
+		// }
+	} else {
+		// res = read_responder_root_public_certificate_from_system_certificate_list(m_use_hash_algo,
+		// 					     // m_use_asym_algo,
+		// 					     &data, &data_size,
+		// 					     &hash, &hash_size);
+		// res = read_responder_root_public_certificate(m_use_hash_algo,
+		// 					     m_use_asym_algo,
+		// 					     &data, &data_size,
+		// 					     &hash, &hash_size);
+		// if (!res) {
+		// 	res = true;
+		// 	hash = responder_public_certificate_chain_hash;
+		// 	hash_size = responder_public_certificate_chain_hash_size;
+		// }
+		// if (res) {
+			zero_mem(&parameter, sizeof(parameter));
+			parameter.location = SPDM_DATA_LOCATION_LOCAL;
+			spdm_set_data(
+				spdm_context,
+				SPDM_DATA_PEER_PUBLIC_ROOT_CERT_HASH,
+				&parameter,
+				responder_public_certificate_chain_hash,
+				responder_public_certificate_chain_hash_size
+				);
+			// Do not free it.
+		// }
+	}
+
+	// res = read_requester_public_certificate_chain(m_use_hash_algo,
+	// 					      m_use_req_asym_algo,
+	// 					      &data, &data_size, NULL,
+	// 					      NULL);
+	// res = false; // The requester public certifiate chain is only needed if mutual authentication is enabled
+
+	// if (!res) {
+	// 	res = true;
+	// 	data = requester_public_certificate_chain_data;
+	// 	data_size = requester_public_certificate_chain_size;
+	// }
+
+	// if (res) {
+		zero_mem(&parameter, sizeof(parameter));
+		parameter.location = SPDM_DATA_LOCATION_LOCAL;
+		data8 = m_use_slot_count;
+		spdm_set_data(
+			spdm_context,
+			SPDM_DATA_LOCAL_SLOT_COUNT,
+			&parameter,
+			&data8,
+			sizeof(data8)
+			);
+
+		for (index = 0; index < m_use_slot_count; index++) {
+			parameter.additional_data[0] = index;
+			spdm_set_data(
+				spdm_context,
+				SPDM_DATA_LOCAL_PUBLIC_CERT_CHAIN,
+				&parameter,
+				requester_public_certificate_chain_data,
+				requester_public_certificate_chain_size
+				);
+		}
+		// printf("read_requester_public_certificate_chain\n");
+		// do not free it
+	// }
+
+	status = spdm_set_data(
+		spdm_context,
+		SPDM_DATA_PSK_HINT,
+		NULL,
+		TEST_PSK_HINT_STRING,
+		sizeof(TEST_PSK_HINT_STRING));
+	if (RETURN_ERROR(status)) {
+		log_err("[SPDM @ U-Boot]: spdm_set_data - %x\n", (uint32)status);
+	}
+}
+
+boolean read_input_file(
+	IN char8 *file_name,
+	OUT void **file_data,
+	OUT uintn *file_size
+)
+{
+	
+}
+
+/**
+ * This function sends GET_DIGEST, GET_CERTIFICATE, CHALLENGE
+ * to authenticate the device.
+ * 
+ * This function is combination of spdm_get_digest, spdm_get_certificate, spdm_challenge.
+ * 
+ * @param  spdm_context                  A pointer to the SPDM context.
+ * @param  slot_mask                     The slots which deploy the CertificateChain.
+ * @param  total_digest_buffer            A pointer to a destination buffer to store the digest buffer.
+ * @param  slot_id                      The number of slot for the certificate chain.
+ * @param  cert_chain_size                On input, indicate the size in bytes of the destination buffer to store the digest buffer.
+ *                                        On output, indicate the size in bytes of the certificate chain.
+ * @param  cert_chain                    A pointer to a destination buffer to store the certificate chain.
+ * @param  measurement_hash_type          The type of the measurement hash.
+ * @param  measurement_hash              A pointer to a destination buffer to store the measurement hash.
+ * 
+ * @retval RETURN_SUCCESS               The authentication is got successfully.
+ * @retval RETURN_DEVICE_ERROR          A device error occurs when communicates with the device.
+ * @retval RETURN_SECURITY_VIOLATION    Any verification fails.
+ * */
+return_status
+spdm_authentication(
+	IN 			void 		*context,
+	OUT 		uint8 	*slot_mask,
+	OUT 		void 		*total_digest_buffer,
+	IN 			uint8 	slot_id,
+	IN OUT 	uintn 	*cert_chain_size,
+	OUT 		void 		*cert_chain,
+	IN 			uint8 	measurement_hash_type,
+	OUT 		void 		*measurement_hash)
+{
+	return_status status;
+	spdm_context_t *spdm_context;
+
+	if ((m_exe_connection & EXE_CONNECTION_DIGEST) != 0) {
+		status = spdm_get_digest(
+							context,
+							slot_mask,
+					 		total_digest_buffer
+							);
+		if (RETURN_ERROR(status)) {
+			return status;
+		}
+	}
+
+	if ((m_exe_connection & EXE_CONNECTION_CERT) != 0) {
+		if (slot_id != 0xFF) {
+			status = spdm_get_certificate(
+								context,
+								slot_id,
+								cert_chain_size,
+								cert_chain
+								);
+			if (RETURN_ERROR(status)) {
+				log_warning("[SPDM @ U-Boot]: do_authentication_via_spdm status 0x%02X\n", (u32)status);
+				return status;
+			}
+		}
+	}
+
+	if ((m_exe_connection & EXE_CONNECTION_CHAL) != 0) {
+		status = spdm_challenge(
+							context,
+							slot_id,
+							measurement_hash_type,
+							measurement_hash
+							);
+		if (RETURN_ERROR(status)) {
+			return status;
+		}
+	}
+	return RETURN_SUCCESS;
+}
+
+/**
+ * This function executes SPDM authentication.
+ * 
+ * @param[in]  spdm_context            The SPDM context for the device.
+ */
+return_status do_authentication_via_spdm(void* spdm_context)
+{
+	return_status status = RETURN_SUCCESS;
+	// void *spdm_context;
+	uint8 slot_mask;
+	// uint8 total_digest_buffer[MAX_HASH_SIZE * MAX_SPDM_SLOT_COUNT];
+	// uint8 measurement_hash[MAX_HASH_SIZE];
+	uintn cert_chain_size;
+	// uint8 cert_chain[MAX_SPDM_CERT_CHAIN_SIZE];
+	uint8 *cert_chain;
+	uint8 *total_digest_buffer;
+	uint8 *measurement_hash;
+
+	cert_chain = malloc(MAX_SPDM_CERT_CHAIN_SIZE);
+	if (cert_chain == NULL) {
+		log_err("Out of mem\n");
+		status = RETURN_OUT_OF_RESOURCES;
+		goto out_auth_ret;
+	}
+
+	total_digest_buffer = malloc(MAX_HASH_SIZE * MAX_SPDM_SLOT_COUNT);
+	if (total_digest_buffer == NULL) {
+		log_err("Out of mem\n");
+		status = RETURN_OUT_OF_RESOURCES;
+		goto out_auth_free_cc;
+	}
+
+	measurement_hash = malloc(MAX_HASH_SIZE);
+	if (measurement_hash == NULL) {
+		log_err("Out of mem\n");
+		status = RETURN_OUT_OF_RESOURCES;
+		goto out_auth_free_db;
+	}
+
+	zero_mem(total_digest_buffer, MAX_HASH_SIZE * MAX_SPDM_SLOT_COUNT);
+	cert_chain_size = MAX_SPDM_CERT_CHAIN_SIZE;
+	zero_mem(cert_chain, MAX_SPDM_CERT_CHAIN_SIZE);
+	zero_mem(measurement_hash, MAX_HASH_SIZE);
+	status = spdm_authentication(
+		spdm_context,
+		&slot_mask,
+		total_digest_buffer,
+		m_use_slot_id,
+		&cert_chain_size,
+		cert_chain,
+		m_use_measurement_summary_hash_type,
+		measurement_hash
+		);	
+
+	free(measurement_hash);
+out_auth_free_db:
+	free(total_digest_buffer);
+out_auth_free_cc:
+	free(cert_chain);
+out_auth_ret:
+	return status;
 }
+#endif /* CONFIG_SPDM */
 
 static const struct blk_ops virtio_blk_ops = {
 	.read	= virtio_blk_read,
diff --git a/drivers/virtio/virtio_blk.h b/drivers/virtio/virtio_blk.h
index 8d8e02fa2e..69159cada8 100644
--- a/drivers/virtio/virtio_blk.h
+++ b/drivers/virtio/virtio_blk.h
@@ -93,6 +93,10 @@ struct __packed virtio_blk_config {
 /* Get device ID command */
 #define VIRTIO_BLK_T_GET_ID	8
 
+#define VIRTIO_BLK_T_SPDM 16
+
+#define VIRTIO_BLK_T_SPDM_APP	32
+
 #ifndef VIRTIO_BLK_NO_LEGACY
 /* Barrier before this op */
 #define VIRTIO_BLK_T_BARRIER	0x80000000
diff --git a/include/blk.h b/include/blk.h
index 2c9c7985a8..f7889f9ab2 100644
--- a/include/blk.h
+++ b/include/blk.h
@@ -97,6 +97,10 @@ struct blk_desc {
 				       lbaint_t blkcnt);
 	void		*priv;		/* driver private struct pointer */
 #endif
+#if CONFIG_IS_ENABLED(SPDM)
+	void *spdm_context;
+	uint32_t *session_id;
+#endif
 };
 
 #define BLOCK_CNT(size, blk_desc) (PAD_COUNT(size, blk_desc->blksz))
diff --git a/lib/Makefile b/lib/Makefile
index 8d8ccc8bbc..a866d9f55b 100644
--- a/lib/Makefile
+++ b/lib/Makefile
@@ -164,3 +164,5 @@ quiet_cmd_build_OID_registry = GEN     $@
 clean-files     += oid_registry_data.c
 
 subdir-ccflags-$(CONFIG_CC_OPTIMIZE_LIBS_FOR_SPEED) += -O2
+
+obj-$(CONFIG_SPDM) += spdm/
diff --git a/lib/sha256.c b/lib/sha256.c
index 4d26aea1c8..c8a8482ce8 100644
--- a/lib/sha256.c
+++ b/lib/sha256.c
@@ -200,6 +200,7 @@ __weak void sha256_process(sha256_context *ctx, const unsigned char *data,
 	}
 }
 
+#ifndef CONFIG_SPDM
 void sha256_update(sha256_context *ctx, const uint8_t *input, uint32_t length)
 {
 	uint32_t left, fill;
@@ -231,6 +232,7 @@ void sha256_update(sha256_context *ctx, const uint8_t *input, uint32_t length)
 	if (length)
 		memcpy((void *) (ctx->buffer + left), (void *) input, length);
 }
+#endif /* CONFIG_SPDM */
 
 static uint8_t sha256_padding[64] = {
 	0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
@@ -267,7 +269,6 @@ void sha256_finish(sha256_context * ctx, uint8_t digest[32])
 	PUT_UINT32_BE(ctx->state[6], digest, 24);
 	PUT_UINT32_BE(ctx->state[7], digest, 28);
 }
-
 /*
  * Output = SHA-256( input buffer ). Trigger the watchdog every 'chunk_sz'
  * bytes of input processed.
diff --git a/lib/spdm/Makefile b/lib/spdm/Makefile
new file mode 100644
index 0000000000..55fcf9c524
--- /dev/null
+++ b/lib/spdm/Makefile
@@ -0,0 +1,54 @@
+obj-y += spdm_glue.o
+
+SPDM_DIR?= /opt/libspdm
+SPDM_BUILD_DIR?= $(SPDM_DIR)/build_uboot
+SPDM_CRYPTO?= mbedtls
+
+SPDM_HEADERS = $(SPDM_DIR)/include
+
+SPDM_INCLUDE := -Iinclude/spdm -Iinclude/spdm/hal
+
+CFLAGS_spdm_glue.o = $(SPDM_INCLUDE)
+
+
+SPDM_INCLUDE_DIR =  \
+        $(SPDM_HEADERS) \
+        $(SPDM_HEADERS)/hal \
+        $(SPDM_HEADERS)/hal/x64 \
+        $(SPDM_HEADERS)/library \
+        $(SPDM_HEADERS)/industry_standard \
+        $(SPDM_DIR)/library/spdm_common_lib \
+        $(SPDM_DIR)/library/spdm_requester_lib \
+        $(SPDM_DIR)/library/spdm_secured_message_lib 
+
+SPDM_HEADER_DIR_KERNEL := $(foreach incdir, $(SPDM_INCLUDE_DIR), $(addprefix include/spdm/,$(notdir $(incdir))))
+
+$(SPDM_HEADER_DIR_KERNEL):
+	mkdir -p include/spdm
+	ln -s $(filter %$(notdir $@), $(SPDM_INCLUDE_DIR)) $@
+	if ls $@/*.h >/dev/null 2>&1; then for i in $@/*.h; do ln -s ../../$$i include/spdm/; done; fi
+
+SPDM_LIBS = \
+        $(SPDM_BUILD_DIR)/lib/librnglib.a \
+        $(SPDM_BUILD_DIR)/lib/libmemlib.a \
+        $(SPDM_BUILD_DIR)/lib/libmalloclib.a \
+        $(SPDM_BUILD_DIR)/lib/libdebuglib.a \
+        $(SPDM_BUILD_DIR)/lib/libcryptlib_$(SPDM_CRYPTO).a \
+        $(SPDM_BUILD_DIR)/lib/lib$(SPDM_CRYPTO)lib.a \
+        $(SPDM_BUILD_DIR)/lib/libspdm_crypt_lib.a \
+        $(SPDM_BUILD_DIR)/lib/libspdm_secured_message_lib.a \
+        $(SPDM_BUILD_DIR)/lib/libspdm_requester_lib.a \
+        $(SPDM_BUILD_DIR)/lib/libspdm_device_secret_lib.a \
+        $(SPDM_BUILD_DIR)/lib/libspdm_common_lib.a \
+        $(SPDM_BUILD_DIR)/lib/libspdm_transport_mctp_lib.a\
+        $(SPDM_BUILD_DIR)/lib/libspdm_transport_pcidoe_lib.a
+
+SPDM_DIR_SUFIX = _spdmlib
+SPDM_OBJ  := $(foreach libfile, $(SPDM_LIBS), $(shell ar t $(libfile) | sed s-^-$$(basename $(libfile))$(SPDM_DIR_SUFIX)/-))
+SPDM_TARGETS := $(addprefix $(obj)/, $(SPDM_OBJ))
+
+spdm_glue-objs := spdm_glue.o $(SPDM_OBJ)
+
+$(SPDM_TARGETS): $(SPDM_LIBS) $(SPDM_HEADER_DIR_KERNEL)
+	mkdir -p $$(dirname $@)
+	cd $$(dirname $@); ar x $(SPDM_BUILD_DIR)/lib/$$(basename $$(dirname $@ | sed s/$(SPDM_DIR_SUFIX)//)) $$(basename $@)
diff --git a/lib/spdm/spdm_glue.c b/lib/spdm/spdm_glue.c
new file mode 100644
index 0000000000..38ed8da4f7
--- /dev/null
+++ b/lib/spdm/spdm_glue.c
@@ -0,0 +1,205 @@
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>		/* kmalloc() */
+#include <linux/completion.h>
+#include <linux/random.h>
+
+#pragma GCC diagnostic ignored "-Wundef"
+#ifdef ARRAY_SIZE
+#undef ARRAY_SIZE
+#endif
+#include "spdm_common_lib.h"
+#pragma GCC diagnostic pop
+
+MODULE_LICENSE("Dual BSD/GPL");
+
+
+// not required if MBEDTLS_HAVE_TIME_DATE is disabled
+// time_t time(time_t *tloc) {
+// 	return 0;
+// }
+
+// not required if MBEDTLS_HAVE_TIME_DATE is disabled
+// but libspdm uses it outside mbedtls...
+struct tm * gmtime_r (const time_t *__restrict tim_p, struct tm *__restrict res);
+struct tm glue_gmtime_tm;
+struct tm *gmtime(const time_t *timep) {
+	return gmtime_r(timep, &glue_gmtime_tm);
+}
+
+
+void __assert(boolean x) {
+	DECLARE_COMPLETION(my_completion);
+	if (!x) {
+    printk("Oh no, your __assert failed!");
+		wait_for_completion(&my_completion);
+  }
+}
+
+void* malloc(size_t size) {
+	return kmalloc(size, GFP_KERNEL);
+}
+
+void free(void * ptr) {
+	kfree(ptr);
+}
+
+// not needed if MBEDTLS_NO_UDBL_DIVISION is defined
+// unsigned long long __udivti3 (unsigned long long a, unsigned long long b) {
+// 	return a/b;
+// }
+
+// not required if MBEDTLS_SELF_TEST is disabled
+// but libspdm uses it outside mbedtls...
+int rand(void) {
+	int i;
+	get_random_bytes(&i, sizeof(i));
+	return i;
+}
+
+int printf(const char *format, ...) {
+	int err;
+	va_list argp;
+  char temp_str[strlen(format)+strlen(KERN_CONT)+1];
+  strcpy(temp_str, KERN_CONT);
+  strcpy(temp_str + strlen(KERN_CONT), format);
+	va_start(argp, format);
+	// err = vprintk(format, argp);
+  err = vprintk(temp_str, argp);
+	va_end(argp);
+	return err;
+}
+
+int putchar(int c){
+	// printk(KERN_ALERT "putchar %02x", c);
+  printk(KERN_ALERT "%c", c);
+	return 0;
+}
+
+// Function used to read certificates from disk.
+// Such functions should not be used or a work aroud shoud be implement here
+boolean read_input_file(IN char8 *file_name, OUT void **file_data,
+                        OUT uintn *file_size) {
+	return FALSE;
+}
+
+// not required if MBEDTLS_NO_PLATFORM_ENTROPY is enabled
+// int mbedtls_platform_entropy_poll( void *data,
+//                             unsigned char *output, size_t len, size_t *olen )
+// {
+// 	return 0;
+// }
+
+// not required if MBEDTLS_HAVEGE_C is enabled
+// int mbedtls_hardclock_poll( void *data,
+//                     unsigned char *output, size_t len, size_t *olen )
+// {
+//     return 0 ;
+// }
+
+void dump_hex_str(IN uint8 *buffer, IN uintn buffer_size) {
+	uintn i;
+	printk(KERN_ALERT "dump_hex_str ");
+	for (i = 0; i < buffer_size; i++) {
+		printk(KERN_CONT "%02X ", buffer[i]);
+	}
+	printk(KERN_ALERT "");
+}
+
+#define SECSPERMIN	60L
+#define MINSPERHOUR	60L
+#define HOURSPERDAY	24L
+#define SECSPERHOUR	(SECSPERMIN * MINSPERHOUR)
+#define SECSPERDAY	(SECSPERHOUR * HOURSPERDAY)
+#define DAYSPERWEEK	7
+#define MONSPERYEAR	12
+
+#define YEAR_BASE	1900
+#define EPOCH_YEAR      1970
+#define EPOCH_WDAY      4
+#define EPOCH_YEARS_SINCE_LEAP 2
+#define EPOCH_YEARS_SINCE_CENTURY 70
+#define EPOCH_YEARS_SINCE_LEAP_CENTURY 370
+
+/* Move epoch from 01.01.1970 to 01.03.0000 (yes, Year 0) - this is the first
+ * day of a 400-year long "era", right after additional day of leap year.
+ * This adjustment is required only for date calculation, so instead of
+ * modifying time_t value (which would require 64-bit operations to work
+ * correctly) it's enough to adjust the calculated number of days since epoch.
+ */
+#define EPOCH_ADJUSTMENT_DAYS	719468L
+/* year to which the adjustment was made */
+#define ADJUSTED_EPOCH_YEAR	0
+/* 1st March of year 0 is Wednesday */
+#define ADJUSTED_EPOCH_WDAY	3
+/* there are 97 leap years in 400-year periods. ((400 - 97) * 365 + 97 * 366) */
+#define DAYS_PER_ERA		146097L
+/* there are 24 leap years in 100-year periods. ((100 - 24) * 365 + 24 * 366) */
+#define DAYS_PER_CENTURY	36524L
+/* there is one leap year every 4 years */
+#define DAYS_PER_4_YEARS	(3 * 365 + 366)
+/* number of days in a non-leap year */
+#define DAYS_PER_YEAR		365
+/* number of days in January */
+#define DAYS_IN_JANUARY		31
+/* number of days in non-leap February */
+#define DAYS_IN_FEBRUARY	28
+/* number of years per era */
+#define YEARS_PER_ERA		400
+
+#define isleap(y) ((((y) % 4) == 0 && ((y) % 100) != 0) || ((y) % 400) == 0)
+
+// from newlib...
+struct tm *
+gmtime_r (const time_t *__restrict tim_p,
+	struct tm *__restrict res)
+{
+  long days, rem;
+  const time_t lcltime = *tim_p;
+  int era, weekday, year;
+  unsigned erayear, yearday, month, day;
+  unsigned long eraday;
+
+  days = lcltime / SECSPERDAY + EPOCH_ADJUSTMENT_DAYS;
+  rem = lcltime % SECSPERDAY;
+  if (rem < 0)
+    {
+      rem += SECSPERDAY;
+      --days;
+    }
+
+  /* compute hour, min, and sec */
+  res->tm_hour = (int) (rem / SECSPERHOUR);
+  rem %= SECSPERHOUR;
+  res->tm_min = (int) (rem / SECSPERMIN);
+  res->tm_sec = (int) (rem % SECSPERMIN);
+
+  /* compute day of week */
+  if ((weekday = ((ADJUSTED_EPOCH_WDAY + days) % DAYSPERWEEK)) < 0)
+    weekday += DAYSPERWEEK;
+  res->tm_wday = weekday;
+
+  /* compute year, month, day & day of year */
+  /* for description of this algorithm see
+   * http://howardhinnant.github.io/date_algorithms.html#civil_from_days */
+  era = (days >= 0 ? days : days - (DAYS_PER_ERA - 1)) / DAYS_PER_ERA;
+  eraday = days - era * DAYS_PER_ERA;	/* [0, 146096] */
+  erayear = (eraday - eraday / (DAYS_PER_4_YEARS - 1) + eraday / DAYS_PER_CENTURY -
+      eraday / (DAYS_PER_ERA - 1)) / 365;	/* [0, 399] */
+  yearday = eraday - (DAYS_PER_YEAR * erayear + erayear / 4 - erayear / 100);	/* [0, 365] */
+  month = (5 * yearday + 2) / 153;	/* [0, 11] */
+  day = yearday - (153 * month + 2) / 5 + 1;	/* [1, 31] */
+  month += month < 10 ? 2 : -10;
+  year = ADJUSTED_EPOCH_YEAR + erayear + era * YEARS_PER_ERA + (month <= 1);
+
+  res->tm_yday = yearday >= DAYS_PER_YEAR - DAYS_IN_JANUARY - DAYS_IN_FEBRUARY ?
+      yearday - (DAYS_PER_YEAR - DAYS_IN_JANUARY - DAYS_IN_FEBRUARY) :
+      yearday + DAYS_IN_JANUARY + DAYS_IN_FEBRUARY + isleap(erayear);
+  res->tm_year = year - YEAR_BASE;
+  res->tm_mon = month;
+  res->tm_mday = day;
+
+  // res->tm_isdst = 0;
+
+  return (res);
+}
-- 
2.42.0

